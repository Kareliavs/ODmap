import {
  COORDINATE_SYSTEM,
  Framebuffer,
  LayerExtension,
  LayersPass,
  Model,
  OrthographicViewport,
  PickLayersPass,
  ProgramManager,
  Renderbuffer,
  Texture2D,
  WebMercatorViewport2 as WebMercatorViewport,
  clear,
  cssToDeviceRatio,
  deepEqual,
  dist,
  equals,
  fp64,
  fp64LowPart,
  init_esm11 as init_esm3,
  init_esm14 as init_esm4,
  init_esm8 as init_esm,
  init_esm9 as init_esm2,
  init_vec3,
  isWebGL2,
  log_default,
  memoize,
  mergeShaders,
  project_default,
  readPixelsToArray,
  withParameters
} from "./chunk-R2UEI6UP.js";
import {
  _defineProperty,
  init_defineProperty
} from "./chunk-K5YS6U7Z.js";
import {
  __esm,
  __export
} from "./chunk-AUZ3RYOM.js";

// node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js
var vs, fs, TARGET, inject, shader_module_default;
var init_shader_module = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js"() {
    init_esm4();
    vs = "\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n";
    fs = "\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n";
    TARGET = {
      source: 0,
      target: 1,
      custom: 2,
      source_target: 3
    };
    inject = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "
    };
    shader_module_default = {
      name: "brushing",
      dependencies: [project_default],
      vs,
      fs,
      inject,
      getUniforms: (opts) => {
        if (!opts || !("viewport" in opts)) {
          return {};
        }
        const {
          brushingEnabled = true,
          brushingRadius = 1e4,
          brushingTarget = "source",
          mousePosition,
          viewport
        } = opts;
        return {
          brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
          brushing_radius: brushingRadius,
          brushing_target: TARGET[brushingTarget] || 0,
          brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js
var defaultProps, BrushingExtension;
var init_brushing_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_shader_module();
    defaultProps = {
      getBrushingTarget: {
        type: "accessor",
        value: [0, 0]
      },
      brushingTarget: "source",
      brushingEnabled: true,
      brushingRadius: 1e4
    };
    BrushingExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default]
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            brushingTargets: {
              size: 2,
              accessor: "getBrushingTarget",
              shaderAttributes: {
                brushingTargets: {
                  divisor: 0
                },
                instanceBrushingTargets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.state.onMouseMove = () => {
          var _this$getCurrentLayer;
          (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.setNeedsRedraw();
        };
        if (context.deck) {
          context.deck.eventManager.on({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
      finalizeState(context, extension) {
        if (context.deck) {
          context.deck.eventManager.off({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
    };
    _defineProperty(BrushingExtension, "defaultProps", defaultProps);
    _defineProperty(BrushingExtension, "extensionName", "BrushingExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const {
    filterRange = [-1, 1],
    filterEnabled = true,
    filterTransformSize = true,
    filterTransformColor = true
  } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      filter_min: filterRange[0],
      filter_softMin: filterSoftRange[0],
      filter_softMax: filterSoftRange[1],
      filter_max: filterRange[1]
    } : {
      filter_min: filterRange.map((r) => r[0]),
      filter_softMin: filterSoftRange.map((r) => r[0]),
      filter_softMax: filterSoftRange.map((r) => r[1]),
      filter_max: filterRange.map((r) => r[1])
    },
    filter_enabled: filterEnabled,
    filter_useSoftMargin: Boolean(opts.filterSoftRange),
    filter_transformSize: filterEnabled && filterTransformSize,
    filter_transformColor: filterEnabled && filterTransformColor
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.filter_min)) {
    const min64High = Math.fround(uniforms.filter_min);
    uniforms.filter_min -= min64High;
    uniforms.filter_softMin -= min64High;
    uniforms.filter_min64High = min64High;
    const max64High = Math.fround(uniforms.filter_max);
    uniforms.filter_max -= max64High;
    uniforms.filter_softMax -= max64High;
    uniforms.filter_max64High = max64High;
  } else {
    const min64High = uniforms.filter_min.map(Math.fround);
    uniforms.filter_min = uniforms.filter_min.map((x, i) => x - min64High[i]);
    uniforms.filter_softMin = uniforms.filter_softMin.map((x, i) => x - min64High[i]);
    uniforms.filter_min64High = min64High;
    const max64High = uniforms.filter_max.map(Math.fround);
    uniforms.filter_max = uniforms.filter_max.map((x, i) => x - max64High[i]);
    uniforms.filter_softMax = uniforms.filter_softMax.map((x, i) => x - max64High[i]);
    uniforms.filter_max64High = max64High;
  }
  return uniforms;
}
var vs2, fs2, inject2, shaderModule, shaderModule64;
var init_shader_module2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js"() {
    vs2 = "\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n";
    fs2 = "\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";
    inject2 = {
      "vs:#main-start": "\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ",
      "vs:#main-end": "\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ",
      "vs:DECKGL_FILTER_SIZE": "\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "
    };
    shaderModule = {
      name: "data-filter",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms
    };
    shaderModule64 = {
      name: "data-filter-fp64",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms: getUniforms64
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js
function supportsFloatTarget(gl) {
  return Boolean(gl.getExtension("EXT_float_blend") && (gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float")));
}
function getFramebuffer(gl, useFloatTarget) {
  if (useFloatTarget) {
    return new Framebuffer(gl, {
      width: 1,
      height: 1,
      attachments: {
        [36064]: new Texture2D(gl, {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126,
          mipmaps: false
        })
      }
    });
  }
  return new Framebuffer(gl, {
    width: 256,
    height: 64,
    depth: false
  });
}
function getModel(gl, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(gl, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    drawMode: 0,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    ...shaderOptions
  });
}
var AGGREGATE_VS, AGGREGATE_FS, parameters;
var init_aggregator = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js"() {
    init_esm3();
    AGGREGATE_VS = "#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n";
    AGGREGATE_FS = "#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n";
    parameters = {
      blend: true,
      blendFunc: [1, 1, 1, 1],
      blendEquation: [32774, 32774],
      depthTest: false
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js
var defaultProps2, DATA_TYPE_FROM_SIZE, DataFilterExtension;
var init_data_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_shader_module2();
    init_aggregator();
    init_esm3();
    defaultProps2 = {
      getFilterValue: {
        type: "accessor",
        value: 0
      },
      onFilteredItemsChange: {
        type: "function",
        value: null,
        optional: true
      },
      filterEnabled: true,
      filterRange: [-1, 1],
      filterSoftRange: null,
      filterTransformSize: true,
      filterTransformColor: true
    };
    DATA_TYPE_FROM_SIZE = {
      1: "float",
      2: "vec2",
      3: "vec3",
      4: "vec4"
    };
    DataFilterExtension = class extends LayerExtension {
      constructor({
        filterSize = 1,
        fp64: fp642 = false,
        countItems = false
      } = {}) {
        if (!DATA_TYPE_FROM_SIZE[filterSize]) {
          throw new Error("filterSize out of range");
        }
        super({
          filterSize,
          fp64: fp642,
          countItems
        });
      }
      getShaders(extension) {
        const {
          filterSize,
          fp64: fp642
        } = extension.opts;
        return {
          modules: [fp642 ? shaderModule64 : shaderModule],
          defines: {
            DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
            DATAFILTER_DOUBLE: Boolean(fp642)
          }
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            filterValues: {
              size: extension.opts.filterSize,
              type: extension.opts.fp64 ? 5130 : 5126,
              accessor: "getFilterValue",
              shaderAttributes: {
                filterValues: {
                  divisor: 0
                },
                instanceFilterValues: {
                  divisor: 1
                }
              }
            }
          });
        }
        const {
          gl
        } = this.context;
        if (attributeManager && extension.opts.countItems) {
          const useFloatTarget = supportsFloatTarget(gl);
          attributeManager.add({
            filterIndices: {
              size: useFloatTarget ? 1 : 2,
              vertexOffset: 1,
              type: 5121,
              normalized: true,
              accessor: (object, {
                index
              }) => {
                const i = object && object.__source ? object.__source.index : index;
                return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];
              },
              shaderAttributes: {
                filterPrevIndices: {
                  vertexOffset: 0
                },
                filterIndices: {
                  vertexOffset: 1
                }
              }
            }
          });
          const filterFBO = getFramebuffer(gl, useFloatTarget);
          const filterModel = getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);
          this.setState({
            filterFBO,
            filterModel
          });
        }
      }
      updateState({
        props,
        oldProps
      }) {
        if (this.state.filterModel) {
          const attributeManager = this.getAttributeManager();
          const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;
          if (filterNeedsUpdate) {
            this.setState({
              filterNeedsUpdate
            });
          }
        }
      }
      draw(params, extension) {
        const {
          filterFBO,
          filterModel,
          filterNeedsUpdate
        } = this.state;
        const {
          onFilteredItemsChange
        } = this.props;
        if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
          const {
            attributes: {
              filterValues,
              filterIndices
            }
          } = this.getAttributeManager();
          filterModel.setVertexCount(this.getNumInstances());
          const {
            gl
          } = this.context;
          clear(gl, {
            framebuffer: filterFBO,
            color: [0, 0, 0, 0]
          });
          filterModel.updateModuleSettings(params.moduleParameters).setAttributes({
            ...filterValues.getShaderAttributes(),
            ...filterIndices && filterIndices.getShaderAttributes()
          }).draw({
            framebuffer: filterFBO,
            parameters: {
              ...parameters,
              viewport: [0, 0, filterFBO.width, filterFBO.height]
            }
          });
          const color = readPixelsToArray(filterFBO);
          let count = 0;
          for (let i = 0; i < color.length; i++) {
            count += color[i];
          }
          onFilteredItemsChange({
            id: this.id,
            count
          });
          this.state.filterNeedsUpdate = false;
        }
      }
      finalizeState() {
        const {
          filterFBO,
          filterModel
        } = this.state;
        if (filterFBO) {
          filterFBO.color.delete();
          filterFBO.delete();
          filterModel.delete();
        }
      }
    };
    _defineProperty(DataFilterExtension, "defaultProps", defaultProps2);
    _defineProperty(DataFilterExtension, "extensionName", "DataFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js
var project64_glsl_default;
var init_project64_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js"() {
    project64_glsl_default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n";
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const {
      viewProjectionMatrix,
      scale
    } = opts.viewport;
    return getMemoizedUniforms({
      viewProjectionMatrix,
      scale
    });
  }
  return {};
}
function calculateUniforms({
  viewProjectionMatrix,
  scale
}) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}
var fp64ify, fp64ifyMatrix4, project64_default, getMemoizedUniforms;
var init_project64 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js"() {
    init_esm2();
    init_esm4();
    init_project64_glsl();
    ({
      fp64ify,
      fp64ifyMatrix4
    } = fp64);
    project64_default = {
      name: "project64",
      dependencies: [project_default, fp64],
      vs: project64_glsl_default,
      getUniforms: getUniforms2
    };
    getMemoizedUniforms = memoize(calculateUniforms);
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js
var Fp64Extension;
var init_fp64_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_project64();
    Fp64Extension = class extends LayerExtension {
      getShaders() {
        const {
          coordinateSystem
        } = this.props;
        if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
          throw new Error("fp64: coordinateSystem must be LNGLAT");
        }
        return {
          modules: [project64_default]
        };
      }
    };
    _defineProperty(Fp64Extension, "extensionName", "Fp64Extension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js
var dashShaders, offsetShaders;
var init_shaders_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js"() {
    dashShaders = {
      inject: {
        "vs:#decl": "\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n",
        "vs:#main-end": "\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n",
        "fs:#decl": "\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
        "fs:#main-start": "\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n"
      }
    };
    offsetShaders = {
      inject: {
        "vs:#decl": "\nattribute float instanceOffsets;\n",
        "vs:DECKGL_FILTER_SIZE": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n",
        "vs:#main-end": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n",
        "fs:#main-start": "\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n"
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js
var defaultProps3, PathStyleExtension;
var init_path_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_shaders_glsl();
    init_vec3();
    defaultProps3 = {
      getDashArray: {
        type: "accessor",
        value: [0, 0]
      },
      getOffset: {
        type: "accessor",
        value: 0
      },
      dashJustified: false,
      dashGapPickable: false
    };
    PathStyleExtension = class extends LayerExtension {
      constructor({
        dash = false,
        offset = false,
        highPrecisionDash = false
      } = {}) {
        super({
          dash: dash || highPrecisionDash,
          offset,
          highPrecisionDash
        });
      }
      isEnabled(layer) {
        return "pathTesselator" in layer.state;
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        let result = {};
        if (extension.opts.dash) {
          result = mergeShaders(result, dashShaders);
        }
        if (extension.opts.offset) {
          result = mergeShaders(result, offsetShaders);
        }
        return result;
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager || !extension.isEnabled(this)) {
          return;
        }
        if (extension.opts.dash) {
          attributeManager.addInstanced({
            instanceDashArrays: {
              size: 2,
              accessor: "getDashArray"
            }
          });
        }
        if (extension.opts.highPrecisionDash) {
          attributeManager.addInstanced({
            instanceDashOffsets: {
              size: 1,
              accessor: "getPath",
              transform: extension.getDashOffsets.bind(this)
            }
          });
        }
        if (extension.opts.offset) {
          attributeManager.addInstanced({
            instanceOffsets: {
              size: 1,
              accessor: "getOffset"
            }
          });
        }
      }
      updateState(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const uniforms = {};
        if (extension.opts.dash) {
          uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
          uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
        }
        this.state.model.setUniforms(uniforms);
      }
      getDashOffsets(path) {
        const result = [0];
        const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
        const isNested = Array.isArray(path[0]);
        const geometrySize = isNested ? path.length : path.length / positionSize;
        let p;
        let prevP;
        for (let i = 0; i < geometrySize - 1; i++) {
          p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);
          p = this.projectPosition(p);
          if (i > 0) {
            result[i] = result[i - 1] + dist(prevP, p);
          }
          prevP = p;
        }
        return result;
      }
    };
    _defineProperty(PathStyleExtension, "defaultProps", defaultProps3);
    _defineProperty(PathStyleExtension, "extensionName", "PathStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js
function getPatternUniforms(opts, uniforms) {
  if (!opts) {
    return {};
  }
  if ("fillPatternTexture" in opts) {
    const {
      fillPatternTexture
    } = opts;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if ("viewport" in opts) {
    const {
      fillPatternMask = true,
      fillPatternEnabled = true
    } = opts;
    const {
      project_uCommonOrigin: coordinateOriginCommon
    } = uniforms;
    const coordinateOriginCommon64Low = [fp64LowPart(coordinateOriginCommon[0]), fp64LowPart(coordinateOriginCommon[1])];
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternVs, patternFs, inject3, patternShaders;
var init_shaders_glsl2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js"() {
    init_esm4();
    patternVs = "\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\n";
    patternFs = "\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\n\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n";
    inject3 = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    fill_uv = geometry.position.xy;\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  "
    };
    patternShaders = {
      name: "fill-pattern",
      vs: patternVs,
      fs: patternFs,
      inject: inject3,
      dependencies: [project_default],
      getUniforms: getPatternUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js
var defaultProps4, FillStyleExtension;
var init_fill_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_esm3();
    init_shaders_glsl2();
    defaultProps4 = {
      fillPatternEnabled: true,
      fillPatternAtlas: {
        type: "image",
        value: null,
        async: true,
        parameters: {
          [10241]: 9729
        }
      },
      fillPatternMapping: {
        type: "object",
        value: {},
        async: true
      },
      fillPatternMask: true,
      getFillPattern: {
        type: "accessor",
        value: (d) => d.pattern
      },
      getFillPatternScale: {
        type: "accessor",
        value: 1
      },
      getFillPatternOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    FillStyleExtension = class extends LayerExtension {
      constructor({
        pattern = false
      } = {}) {
        super({
          pattern
        });
      }
      isEnabled(layer) {
        return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        return {
          modules: [extension.opts.pattern && patternShaders].filter(Boolean)
        };
      }
      initializeState(context, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const attributeManager = this.getAttributeManager();
        if (extension.opts.pattern) {
          attributeManager.add({
            fillPatternFrames: {
              size: 4,
              accessor: "getFillPattern",
              transform: extension.getPatternFrame.bind(this),
              shaderAttributes: {
                fillPatternFrames: {
                  divisor: 0
                },
                instanceFillPatternFrames: {
                  divisor: 1
                }
              }
            },
            fillPatternScales: {
              size: 1,
              accessor: "getFillPatternScale",
              defaultValue: 1,
              shaderAttributes: {
                fillPatternScales: {
                  divisor: 0
                },
                instanceFillPatternScales: {
                  divisor: 1
                }
              }
            },
            fillPatternOffsets: {
              size: 2,
              accessor: "getFillPatternOffset",
              shaderAttributes: {
                fillPatternOffsets: {
                  divisor: 0
                },
                instanceFillPatternOffsets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.setState({
          emptyTexture: new Texture2D(this.context.gl, {
            data: new Uint8Array(4),
            width: 1,
            height: 1
          })
        });
      }
      updateState({
        props,
        oldProps
      }, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
          this.getAttributeManager().invalidate("getFillPattern");
        }
      }
      draw(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const {
          fillPatternAtlas
        } = this.props;
        this.setModuleParameters({
          fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
        });
      }
      finalizeState() {
        const {
          emptyTexture
        } = this.state;
        emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();
      }
      getPatternFrame(name) {
        const {
          fillPatternMapping
        } = this.getCurrentLayer().props;
        const def = fillPatternMapping && fillPatternMapping[name];
        return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
      }
    };
    _defineProperty(FillStyleExtension, "defaultProps", defaultProps4);
    _defineProperty(FillStyleExtension, "extensionName", "FillStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js
var defaultProps5, shaderFunction, shaderModuleVs, injectionVs, shaderModuleFs, injectionFs, ClipExtension;
var init_clip_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js"() {
    init_defineProperty();
    init_esm4();
    defaultProps5 = {
      clipBounds: [0, 0, 1, 1],
      clipByInstance: void 0
    };
    shaderFunction = "\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n";
    shaderModuleVs = {
      name: "clip-vs",
      vs: shaderFunction
    };
    injectionVs = {
      "vs:#decl": "\nvarying float clip_isVisible;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n",
      "fs:#decl": "\nvarying float clip_isVisible;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (clip_isVisible < 0.5) discard;\n"
    };
    shaderModuleFs = {
      name: "clip-fs",
      fs: shaderFunction
    };
    injectionFs = {
      "vs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_commonPosition = geometry.position.xy;\n",
      "fs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n"
    };
    ClipExtension = class extends LayerExtension {
      getShaders() {
        let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.clipByInstance !== void 0) {
          clipByInstance = Boolean(this.props.clipByInstance);
        }
        this.state.clipByInstance = clipByInstance;
        return clipByInstance ? {
          modules: [shaderModuleVs],
          inject: injectionVs
        } : {
          modules: [shaderModuleFs],
          inject: injectionFs
        };
      }
      draw({
        uniforms
      }) {
        const {
          clipBounds
        } = this.props;
        if (this.state.clipByInstance) {
          uniforms.clip_bounds = clipBounds;
        } else {
          const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
          const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
          uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];
        }
      }
    };
    _defineProperty(ClipExtension, "defaultProps", defaultProps5);
    _defineProperty(ClipExtension, "extensionName", "ClipExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js
var vs3, inject4, getCollisionUniforms, shader_module_default2;
var init_shader_module3 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js"() {
    init_esm4();
    vs3 = "\n#ifdef NON_INSTANCED_MODEL\nattribute float collisionPriorities;\n#else\nattribute float instanceCollisionPriorities;\n#endif\n\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture2D(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision_enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project_uViewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n";
    inject4 = {
      "vs:#decl": "\n  float collision_fade = 1.0;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  if (collision_sort) {\n    #ifdef NON_INSTANCED_MODEL\n    float collisionPriority = collisionPriorities;\n    #else\n    float collisionPriority = instanceCollisionPriorities;\n    #endif\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision_enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n  color.a *= collision_fade;\n  "
    };
    getCollisionUniforms = (opts, uniforms) => {
      if (!opts || !("dummyCollisionMap" in opts)) {
        return {};
      }
      const {
        collisionFBO,
        drawToCollisionMap,
        dummyCollisionMap
      } = opts;
      return {
        collision_sort: Boolean(drawToCollisionMap),
        collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap
      };
    };
    shader_module_default2 = {
      name: "collision",
      dependencies: [project_default],
      vs: vs3,
      inject: inject4,
      getUniforms: getCollisionUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js
var CollisionFilterPass;
var init_collision_filter_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js"() {
    init_esm3();
    init_esm4();
    CollisionFilterPass = class extends LayersPass {
      renderCollisionMap(target, options) {
        const gl = this.gl;
        const padding = 1;
        return withParameters(gl, {
          scissorTest: true,
          scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],
          clearColor: [0, 0, 0, 0],
          blend: false,
          depthTest: true,
          depthRange: [0, 1]
        }, () => this.render({
          ...options,
          target,
          pass: "collision"
        }));
      }
      getModuleParameters() {
        return {
          drawToCollisionMap: true,
          pickingActive: 1,
          pickingAttribute: false,
          lightSources: {}
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js
var MaskPass;
var init_mask_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js"() {
    init_defineProperty();
    init_esm3();
    init_esm4();
    MaskPass = class extends LayersPass {
      constructor(gl, props) {
        super(gl, props);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "fbo", void 0);
        const {
          mapSize = 2048
        } = props;
        this.maskMap = new Texture2D(gl, {
          width: mapSize,
          height: mapSize,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.fbo = new Framebuffer(gl, {
          id: "maskmap",
          width: mapSize,
          height: mapSize,
          attachments: {
            [36064]: this.maskMap
          }
        });
      }
      render(options) {
        const gl = this.gl;
        const colorMask = [false, false, false, false];
        colorMask[options.channel] = true;
        return withParameters(gl, {
          clearColor: [255, 255, 255, 255],
          blend: true,
          blendFunc: [0, 1],
          blendEquation: 32778,
          colorMask,
          depthTest: false
        }, () => super.render({
          ...options,
          target: this.fbo,
          pass: "mask"
        }));
      }
      shouldDrawLayer(layer) {
        return layer.props.operation.includes("mask");
      }
      delete() {
        this.fbo.delete();
        this.maskMap.delete();
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {
        viewport,
        autoOffset: false
      });
      const topRightCommon = layer.projectPosition(layerBounds[1], {
        viewport,
        autoOffset: false
      });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
function makeViewport(opts) {
  const {
    bounds,
    viewport,
    border = 0
  } = opts;
  const {
    isGeospatial
  } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);
  let {
    width,
    height,
    zoom
  } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale), 20);
  } else if (!width || !height) {
    const scale = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r = maxSize / Math.max(width, height);
      width = Math.round(width * r);
      height = Math.round(height * r);
      zoom += Math.log2(r);
    }
  }
  return isGeospatial ? new WebMercatorViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}
var MAX_VIEWPORT_SIZE;
var init_projection_utils = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js"() {
    init_esm4();
    MAX_VIEWPORT_SIZE = 2048;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js
var MaskEffect;
var init_mask_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js"() {
    init_defineProperty();
    init_esm4();
    init_esm3();
    init_esm();
    init_mask_pass();
    init_projection_utils();
    MaskEffect = class {
      constructor() {
        _defineProperty(this, "id", "mask-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 0);
        _defineProperty(this, "dummyMaskMap", void 0);
        _defineProperty(this, "channels", []);
        _defineProperty(this, "masks", null);
        _defineProperty(this, "maskPass", void 0);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking
      }) {
        let didRender = false;
        if (!this.dummyMaskMap) {
          this.dummyMaskMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return {
            didRender
          };
        }
        const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes("mask"));
        if (maskLayers.length === 0) {
          this.masks = null;
          this.channels.length = 0;
          return {
            didRender
          };
        }
        this.masks = {};
        if (!this.maskPass) {
          this.maskPass = new MaskPass(gl, {
            id: "default-mask"
          });
          this.maskMap = this.maskPass.maskMap;
        }
        const channelMap = this._sortMaskChannels(maskLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
        if (viewport.resolution !== void 0) {
          log_default.warn("MaskExtension is not supported in GlobeView")();
          return {
            didRender
          };
        }
        for (const maskId in channelMap) {
          const result = this._renderChannel(channelMap[maskId], {
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
          didRender || (didRender = result);
        }
        return {
          didRender
        };
      }
      _renderChannel(channelInfo, {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        let didRender = false;
        const oldChannelInfo = this.channels[channelInfo.index];
        if (!oldChannelInfo) {
          return didRender;
        }
        const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => layer !== oldChannelInfo.layers[i] || layer.props.transitions) || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);
        channelInfo.bounds = oldChannelInfo.bounds;
        channelInfo.maskBounds = oldChannelInfo.maskBounds;
        this.channels[channelInfo.index] = channelInfo;
        if (maskChanged || viewportChanged) {
          this.lastViewport = viewport;
          const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
          channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
          if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
            const {
              maskPass,
              maskMap
            } = this;
            const maskViewport = layerBounds && makeViewport({
              bounds: channelInfo.bounds,
              viewport,
              width: maskMap.width,
              height: maskMap.height,
              border: 1
            });
            channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
            maskPass.render({
              pass: "mask",
              channel: channelInfo.index,
              layers: channelInfo.layers,
              layerFilter,
              viewports: maskViewport ? [maskViewport] : [],
              onViewportActive,
              views,
              moduleParameters: {
                devicePixelRatio: 1
              }
            });
            didRender = true;
          }
        }
        this.masks[channelInfo.id] = {
          index: channelInfo.index,
          bounds: channelInfo.maskBounds,
          coordinateOrigin: channelInfo.coordinateOrigin,
          coordinateSystem: channelInfo.coordinateSystem
        };
        return didRender;
      }
      _sortMaskChannels(maskLayers) {
        const channelMap = {};
        let channelCount = 0;
        for (const layer of maskLayers) {
          const {
            id
          } = layer.root;
          let channelInfo = channelMap[id];
          if (!channelInfo) {
            if (++channelCount > 4) {
              log_default.warn("Too many mask layers. The max supported is 4")();
              continue;
            }
            channelInfo = {
              id,
              index: this.channels.findIndex((c) => (c === null || c === void 0 ? void 0 : c.id) === id),
              layers: [],
              layerBounds: [],
              coordinateOrigin: layer.root.props.coordinateOrigin,
              coordinateSystem: layer.root.props.coordinateSystem
            };
            channelMap[id] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
        }
        for (let i = 0; i < 4; i++) {
          const channelInfo = this.channels[i];
          if (!channelInfo || !(channelInfo.id in channelMap)) {
            this.channels[i] = null;
          }
        }
        for (const maskId in channelMap) {
          const channelInfo = channelMap[maskId];
          if (channelInfo.index < 0) {
            channelInfo.index = this.channels.findIndex((c) => !c);
            this.channels[channelInfo.index] = channelInfo;
          }
        }
        return channelMap;
      }
      getModuleParameters() {
        return {
          maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
          maskChannels: this.masks
        };
      }
      cleanup() {
        if (this.dummyMaskMap) {
          this.dummyMaskMap.delete();
          this.dummyMaskMap = void 0;
        }
        if (this.maskPass) {
          this.maskPass.delete();
          this.maskPass = void 0;
          this.maskMap = void 0;
        }
        this.lastViewport = void 0;
        this.masks = null;
        this.channels.length = 0;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js
var DOWNSCALE, CollisionFilterEffect;
var init_collision_filter_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js"() {
    init_defineProperty();
    init_esm3();
    init_esm();
    init_esm4();
    init_collision_filter_pass();
    init_mask_effect();
    DOWNSCALE = 2;
    CollisionFilterEffect = class {
      constructor() {
        _defineProperty(this, "id", "collision-filter-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 1);
        _defineProperty(this, "channels", {});
        _defineProperty(this, "collisionFilterPass", void 0);
        _defineProperty(this, "collisionFBOs", {});
        _defineProperty(this, "dummyCollisionMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        effects: allEffects,
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking,
        preRenderStats = {}
      }) {
        var _preRenderStats$mask;
        if (!this.dummyCollisionMap) {
          this.dummyCollisionMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return;
        }
        const collisionLayers = layers.filter(({
          props: {
            visible,
            collisionEnabled
          }
        }) => visible && collisionEnabled);
        if (collisionLayers.length === 0) {
          this.channels = {};
          return;
        }
        if (!this.collisionFilterPass) {
          this.collisionFilterPass = new CollisionFilterPass(gl, {
            id: "default-collision-filter"
          });
        }
        const effects = allEffects === null || allEffects === void 0 ? void 0 : allEffects.filter((e) => e.constructor === MaskEffect);
        const maskEffectRendered = (_preRenderStats$mask = preRenderStats["mask-effect"]) === null || _preRenderStats$mask === void 0 ? void 0 : _preRenderStats$mask.didRender;
        const channels = this._groupByCollisionGroup(gl, collisionLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
        for (const collisionGroup in channels) {
          const collisionFBO = this.collisionFBOs[collisionGroup];
          const renderInfo = channels[collisionGroup];
          collisionFBO.resize({
            width: gl.canvas.width / DOWNSCALE,
            height: gl.canvas.height / DOWNSCALE
          });
          this._render(renderInfo, {
            effects,
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
        }
      }
      _render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        const {
          collisionGroup
        } = renderInfo;
        const oldRenderInfo = this.channels[collisionGroup];
        if (!oldRenderInfo) {
          return;
        }
        const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
        this.channels[collisionGroup] = renderInfo;
        if (needsRender) {
          this.lastViewport = viewport;
          const collisionFBO = this.collisionFBOs[collisionGroup];
          this.collisionFilterPass.renderCollisionMap(collisionFBO, {
            pass: "collision-filter",
            isPicking: true,
            layers: renderInfo.layers,
            effects,
            layerFilter,
            viewports: viewport ? [viewport] : [],
            onViewportActive,
            views,
            moduleParameters: {
              dummyCollisionMap: this.dummyCollisionMap,
              devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE
            }
          });
        }
      }
      _groupByCollisionGroup(gl, collisionLayers) {
        const channelMap = {};
        for (const layer of collisionLayers) {
          const {
            collisionGroup
          } = layer.props;
          let channelInfo = channelMap[collisionGroup];
          if (!channelInfo) {
            channelInfo = {
              collisionGroup,
              layers: [],
              layerBounds: [],
              allLayersLoaded: true
            };
            channelMap[collisionGroup] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
          if (!layer.isLoaded) {
            channelInfo.allLayersLoaded = false;
          }
        }
        for (const collisionGroup of Object.keys(channelMap)) {
          if (!this.collisionFBOs[collisionGroup]) {
            this.createFBO(gl, collisionGroup);
          }
          if (!this.channels[collisionGroup]) {
            this.channels[collisionGroup] = channelMap[collisionGroup];
          }
        }
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          if (!channelMap[collisionGroup]) {
            this.destroyFBO(collisionGroup);
          }
        }
        return channelMap;
      }
      getModuleParameters(layer) {
        const {
          collisionGroup
        } = layer.props;
        const {
          collisionFBOs,
          dummyCollisionMap
        } = this;
        return {
          collisionFBO: collisionFBOs[collisionGroup],
          dummyCollisionMap
        };
      }
      cleanup() {
        if (this.dummyCollisionMap) {
          this.dummyCollisionMap.delete();
          this.dummyCollisionMap = void 0;
        }
        this.channels = {};
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          this.destroyFBO(collisionGroup);
        }
        this.collisionFBOs = {};
        this.lastViewport = void 0;
      }
      createFBO(gl, collisionGroup) {
        const {
          width,
          height
        } = gl.canvas;
        const collisionMap = new Texture2D(gl, {
          width,
          height,
          parameters: {
            [10241]: 9728,
            [10240]: 9728,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        const depthBuffer = new Renderbuffer(gl, {
          format: 33189,
          width,
          height
        });
        this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {
          id: "Collision-".concat(collisionGroup),
          width,
          height,
          attachments: {
            [36064]: collisionMap,
            [36096]: depthBuffer
          }
        });
      }
      destroyFBO(collisionGroup) {
        const fbo = this.collisionFBOs[collisionGroup];
        for (const attachment of Object.values(fbo.attachments)) {
          attachment.delete();
        }
        fbo.delete();
        delete this.collisionFBOs[collisionGroup];
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js
var defaultProps6, CollisionFilterExtension;
var init_collision_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_shader_module3();
    init_collision_filter_effect();
    defaultProps6 = {
      getCollisionPriority: {
        type: "accessor",
        value: 0
      },
      collisionEnabled: true,
      collisionGroup: {
        type: "string",
        value: "default"
      },
      collisionTestProps: {}
    };
    CollisionFilterExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default2]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        const {
          collisionEnabled
        } = this.props;
        const {
          collisionFBO,
          drawToCollisionMap
        } = moduleParameters;
        const enabled = collisionEnabled && Boolean(collisionFBO);
        uniforms.collision_enabled = enabled;
        if (drawToCollisionMap) {
          this.props = this.clone(this.props.collisionTestProps).props;
        }
      }
      initializeState(context, extension) {
        var _this$context$deck;
        if (this.getAttributeManager() === null) {
          return;
        }
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new CollisionFilterEffect());
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
          collisionPriorities: {
            size: 1,
            accessor: "getCollisionPriority",
            shaderAttributes: {
              collisionPriorities: {
                divisor: 0
              },
              instanceCollisionPriorities: {
                divisor: 1
              }
            }
          }
        });
      }
      getNeedsPickingBuffer() {
        return this.props.collisionEnabled;
      }
    };
    _defineProperty(CollisionFilterExtension, "defaultProps", defaultProps6);
    _defineProperty(CollisionFilterExtension, "extensionName", "CollisionFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js
var vs4, fs3, inject5, getMaskUniforms, shader_module_default3;
var init_shader_module4 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js"() {
    init_esm4();
    vs4 = "\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n";
    fs3 = "\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask_enabled) {\n    return true;\n  }\n  vec4 maskColor = texture2D(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask_channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask_channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask_channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask_channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask_inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n";
    inject5 = {
      "vs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "vs:#main-end": "\n   vec4 mask_common_position;\n   if (mask_maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n",
      "fs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "fs:#main-start": "\n  if (mask_enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);\n    gl_FragColor = texture2D(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n"
    };
    getMaskUniforms = (opts) => {
      if (opts && "maskMap" in opts) {
        return {
          mask_texture: opts.maskMap
        };
      }
      return {};
    };
    shader_module_default3 = {
      name: "mask",
      dependencies: [project_default],
      vs: vs4,
      fs: fs3,
      inject: inject5,
      getUniforms: getMaskUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js
var defaultProps7, MaskExtension;
var init_mask_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_shader_module4();
    init_mask_effect();
    defaultProps7 = {
      maskId: "",
      maskByInstance: void 0,
      maskInverted: false
    };
    MaskExtension = class extends LayerExtension {
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new MaskEffect());
      }
      getShaders() {
        let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.maskByInstance !== void 0) {
          maskByInstance = Boolean(this.props.maskByInstance);
        }
        this.state.maskByInstance = maskByInstance;
        return {
          modules: [shader_module_default3]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        uniforms.mask_maskByInstance = this.state.maskByInstance;
        const {
          maskId,
          maskInverted
        } = this.props;
        const {
          maskChannels
        } = moduleParameters;
        const {
          viewport
        } = context;
        if (maskChannels && maskChannels[maskId]) {
          const {
            index,
            bounds,
            coordinateOrigin: fromCoordinateOrigin
          } = maskChannels[maskId];
          let {
            coordinateSystem: fromCoordinateSystem
          } = maskChannels[maskId];
          uniforms.mask_enabled = true;
          uniforms.mask_channel = index;
          uniforms.mask_inverted = maskInverted;
          if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
            fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
          }
          const opts = {
            modelMatrix: null,
            fromCoordinateOrigin,
            fromCoordinateSystem
          };
          const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
          const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
          uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
        } else {
          if (maskId) {
            log_default.warn("Could not find a mask layer with id: ".concat(maskId))();
          }
          uniforms.mask_enabled = false;
        }
      }
    };
    _defineProperty(MaskExtension, "defaultProps", defaultProps7);
    _defineProperty(MaskExtension, "extensionName", "MaskExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js
var TERRAIN_MODE, TERRAIN_MODE_CONSTANTS, terrainModule;
var init_shader_module5 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js"() {
    init_esm4();
    TERRAIN_MODE = {
      NONE: 0,
      WRITE_HEIGHT_MAP: 1,
      USE_HEIGHT_MAP: 2,
      USE_COVER: 3,
      USE_COVER_ONLY: 4,
      SKIP: 5
    };
    TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => "const float TERRAIN_MODE_".concat(key, " = ").concat(TERRAIN_MODE[key], ".0;")).join("\n");
    terrainModule = {
      name: "terrain",
      dependencies: [project_default],
      inject: {
        "vs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "vs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n",
        "vs:DECKGL_FILTER_GL_POSITION": "\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    ",
        "fs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "fs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    ",
        "fs:DECKGL_FILTER_COLOR": "\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    "
      },
      getUniforms: (opts = {}, uniforms) => {
        if ("dummyHeightMap" in opts) {
          const {
            drawToTerrainHeightMap,
            heightMap,
            heightMapBounds,
            dummyHeightMap,
            terrainCover,
            useTerrainHeightMap,
            terrainSkipRender
          } = opts;
          const {
            project_uCommonOrigin
          } = uniforms;
          let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
          let sampler = dummyHeightMap;
          let bounds = null;
          if (drawToTerrainHeightMap) {
            mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
            bounds = heightMapBounds;
          } else if (useTerrainHeightMap && heightMap) {
            mode = TERRAIN_MODE.USE_HEIGHT_MAP;
            sampler = heightMap;
            bounds = heightMapBounds;
          } else if (terrainCover) {
            const isPicking = opts.pickingActive;
            sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
            if (isPicking) {
              mode = TERRAIN_MODE.SKIP;
            }
            if (sampler) {
              mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
              bounds = terrainCover.bounds;
            } else {
              sampler = dummyHeightMap;
            }
          }
          return {
            terrain_mode: mode,
            terrain_map: sampler,
            terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]
          };
        }
        return null;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js
function createRenderTarget(gl, opts) {
  return new Framebuffer(gl, {
    id: opts.id,
    attachments: {
      [36064]: new Texture2D(gl, {
        ...opts.float && {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126
        },
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      })
    }
  });
}
var init_utils = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js"() {
    init_esm3();
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const {
      tile
    } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}
var TerrainCover;
var init_terrain_cover = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js"() {
    init_defineProperty();
    init_utils();
    init_projection_utils();
    TerrainCover = class {
      constructor(targetLayer) {
        _defineProperty(this, "isDirty", true);
        _defineProperty(this, "targetLayer", void 0);
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "pickingFbo", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "tile", void 0);
        _defineProperty(this, "targetBounds", null);
        _defineProperty(this, "targetBoundsCommon", null);
        this.targetLayer = targetLayer;
        this.tile = getTile(targetLayer);
      }
      get id() {
        return this.targetLayer.id;
      }
      get isActive() {
        return Boolean(this.targetLayer.getCurrentLayer());
      }
      shouldUpdate({
        targetLayer,
        viewport,
        layers,
        layerNeedsRedraw
      }) {
        if (targetLayer) {
          this.targetLayer = targetLayer;
        }
        const sizeChanged = viewport ? this._updateViewport(viewport) : false;
        let layersChanged = layers ? this._updateLayers(layers) : false;
        if (layerNeedsRedraw) {
          for (const id of this.layers) {
            if (layerNeedsRedraw[id]) {
              layersChanged = true;
              break;
            }
          }
        }
        return layersChanged || sizeChanged;
      }
      _updateLayers(layers) {
        let needsRedraw = false;
        layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
        if (layers.length !== this.layers.length) {
          needsRedraw = true;
        } else {
          for (let i = 0; i < layers.length; i++) {
            const id = layers[i].id;
            if (id !== this.layers[i]) {
              needsRedraw = true;
              break;
            }
          }
        }
        if (needsRedraw) {
          this.layers = layers.map((layer) => layer.id);
        }
        return needsRedraw;
      }
      _updateViewport(viewport) {
        const targetLayer = this.targetLayer;
        let shouldRedraw = false;
        if (this.tile && "boundingBox" in this.tile) {
          if (!this.targetBounds) {
            shouldRedraw = true;
            this.targetBounds = this.tile.boundingBox;
            const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
            const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
            this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];
          }
        } else if (this.targetBounds !== targetLayer.getBounds()) {
          shouldRedraw = true;
          this.targetBounds = targetLayer.getBounds();
          this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
        }
        if (!this.targetBoundsCommon) {
          return false;
        }
        const newZoom = Math.ceil(viewport.zoom + 0.5);
        if (this.tile) {
          this.bounds = this.targetBoundsCommon;
        } else {
          var _this$renderViewport;
          const oldZoom = (_this$renderViewport = this.renderViewport) === null || _this$renderViewport === void 0 ? void 0 : _this$renderViewport.zoom;
          shouldRedraw = shouldRedraw || newZoom !== oldZoom;
          const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
          const oldBounds = this.bounds;
          shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);
          this.bounds = newBounds;
        }
        if (shouldRedraw) {
          this.renderViewport = makeViewport({
            bounds: this.bounds,
            zoom: newZoom,
            viewport
          });
        }
        return shouldRedraw;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.targetLayer.context.gl, {
            id: this.id
          });
        }
        return this.fbo;
      }
      getPickingFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
          return null;
        }
        if (!this.pickingFbo) {
          this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {
            id: "".concat(this.id, "-picking")
          });
        }
        return this.pickingFbo;
      }
      filterLayers(layers) {
        return layers.filter(({
          id
        }) => this.layers.includes(id));
      }
      delete() {
        const {
          fbo,
          pickingFbo
        } = this;
        if (fbo) {
          fbo.texture.delete();
          fbo.delete();
        }
        if (pickingFbo) {
          pickingFbo.texture.delete();
          pickingFbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js
var TerrainPass;
var init_terrain_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js"() {
    init_esm3();
    init_esm4();
    TerrainPass = class extends LayersPass {
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
            result.push(layer);
          }
        }
        return result;
      }
      renderHeightMap(heightMap, opts) {
        const target = heightMap.getRenderFramebuffer();
        const viewport = heightMap.renderViewport;
        if (!target || !viewport) {
          return;
        }
        target.resize(viewport);
        withParameters(this.gl, {
          clearColor: [0, 0, 0, 0],
          blend: true,
          blendFunc: [1, 1],
          blendEquation: 32776,
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-height-map",
          layers: opts.layers,
          viewports: [viewport],
          effects: []
        }));
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getRenderFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        target.resize(viewport);
        withParameters(this.gl, {
          clearColor: [0, 0, 0, 0],
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-cover-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport]
        }));
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js
var TerrainPickingPass;
var init_terrain_picking_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js"() {
    init_defineProperty();
    init_esm4();
    init_esm3();
    TerrainPickingPass = class extends PickLayersPass {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "drawParameters", {});
      }
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        this.drawParameters = {};
        this._resetColorEncoder(opts.pickZ);
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
            result.push(layer);
            this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;
          }
        }
        return result;
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getPickingFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        const terrainLayer = terrainCover.targetLayer;
        if (terrainLayer.props.pickable) {
          layers.unshift(terrainLayer);
        }
        target.resize(viewport);
        withParameters(this.gl, {
          depthTest: false
        }, () => this.render({
          ...opts,
          pickingFBO: target,
          pass: "terrain-cover-picking-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport],
          cullRect: void 0,
          deviceRect: viewport,
          pickZ: false
        }));
      }
      getLayerParameters(layer, layerIndex, viewport) {
        if (this.drawParameters[layer.id]) {
          return this.drawParameters[layer.id];
        }
        const parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
        parameters2.blend = true;
        return parameters2;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js
var MAP_MAX_SIZE, HeightMapBuilder;
var init_height_map_builder = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js"() {
    init_defineProperty();
    init_esm3();
    init_projection_utils();
    init_utils();
    MAP_MAX_SIZE = 2048;
    HeightMapBuilder = class {
      static isSupported(gl) {
        return Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        });
      }
      constructor(gl) {
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "layersBounds", []);
        _defineProperty(this, "layersBoundsCommon", null);
        _defineProperty(this, "lastViewport", null);
        this.gl = gl;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.gl, {
            id: "height-map",
            float: true
          });
        }
        return this.fbo;
      }
      shouldUpdate({
        layers,
        viewport
      }) {
        const layersChanged = layers.length !== this.layers.length || layers.some((layer, i) => layer !== this.layers[i] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i]);
        if (layersChanged) {
          this.layers = layers;
          this.layersBounds = layers.map((layer) => layer.getBounds());
          this.layersBoundsCommon = joinLayerBounds(layers, viewport);
        }
        const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
        if (!this.layersBoundsCommon) {
          this.renderViewport = null;
        } else if (layersChanged || viewportChanged) {
          const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
          if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
            this.renderViewport = null;
            return false;
          }
          this.bounds = bounds;
          this.lastViewport = viewport;
          const scale = viewport.scale;
          const pixelWidth = (bounds[2] - bounds[0]) * scale;
          const pixelHeight = (bounds[3] - bounds[1]) * scale;
          this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
            bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],
            zoom: viewport.zoom,
            width: Math.min(pixelWidth, MAP_MAX_SIZE),
            height: Math.min(pixelHeight, MAP_MAX_SIZE),
            viewport
          }) : null;
          return true;
        }
        return false;
      }
      delete() {
        if (this.fbo) {
          this.fbo.color.delete();
          this.fbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js
var TerrainEffect;
var init_terrain_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js"() {
    init_defineProperty();
    init_esm3();
    init_esm4();
    init_shader_module5();
    init_terrain_cover();
    init_terrain_pass();
    init_terrain_picking_pass();
    init_height_map_builder();
    TerrainEffect = class {
      constructor() {
        _defineProperty(this, "id", "terrain-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "isPicking", false);
        _defineProperty(this, "isDrapingEnabled", false);
        _defineProperty(this, "dummyHeightMap", void 0);
        _defineProperty(this, "heightMap", void 0);
        _defineProperty(this, "terrainPass", void 0);
        _defineProperty(this, "terrainPickingPass", void 0);
        _defineProperty(this, "terrainCovers", /* @__PURE__ */ new Map());
      }
      initialize(gl) {
        this.dummyHeightMap = new Texture2D(gl, {
          width: 1,
          height: 1,
          data: new Uint8Array([0, 0, 0, 0])
        });
        this.terrainPass = new TerrainPass(gl, {
          id: "terrain"
        });
        this.terrainPickingPass = new TerrainPickingPass(gl, {
          id: "terrain-picking"
        });
        if (HeightMapBuilder.isSupported(gl)) {
          this.heightMap = new HeightMapBuilder(gl);
        } else {
          log_default.warn("Terrain offset mode is not supported by this browser")();
        }
        ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);
      }
      preRender(gl, opts) {
        if (!this.dummyHeightMap) {
          this.initialize(gl);
          for (const layer of opts.layers) {
            if (layer.props.operation.includes("terrain")) {
              layer.setChangeFlags({
                extensionsChanged: true
              });
            }
          }
        }
        if (opts.pickZ) {
          this.isDrapingEnabled = false;
          return;
        }
        const {
          viewports,
          isPicking = false
        } = opts;
        this.isPicking = isPicking;
        this.isDrapingEnabled = true;
        const viewport = viewports[0];
        const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
        const terrainLayers = layers.filter((l) => l.props.operation.includes("terrain"));
        if (terrainLayers.length === 0) {
          return;
        }
        if (!isPicking) {
          const offsetLayers = layers.filter((l) => l.state.terrainDrawMode === "offset");
          if (offsetLayers.length > 0) {
            this._updateHeightMap(terrainLayers, viewport, opts);
          }
        }
        const drapeLayers = layers.filter((l) => l.state.terrainDrawMode === "drape");
        this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
      }
      getModuleParameters(layer) {
        var _this$heightMap, _this$heightMap2;
        const {
          terrainDrawMode
        } = layer.state;
        return {
          heightMap: (_this$heightMap = this.heightMap) === null || _this$heightMap === void 0 ? void 0 : _this$heightMap.getRenderFramebuffer(),
          heightMapBounds: (_this$heightMap2 = this.heightMap) === null || _this$heightMap2 === void 0 ? void 0 : _this$heightMap2.bounds,
          dummyHeightMap: this.dummyHeightMap,
          terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
          useTerrainHeightMap: terrainDrawMode === "offset",
          terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
        };
      }
      cleanup() {
        if (this.dummyHeightMap) {
          this.dummyHeightMap.delete();
          this.dummyHeightMap = void 0;
        }
        if (this.heightMap) {
          this.heightMap.delete();
          this.heightMap = void 0;
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.delete();
        }
        this.terrainCovers.clear();
      }
      _updateHeightMap(terrainLayers, viewport, opts) {
        if (!this.heightMap) {
          return;
        }
        const shouldUpdate = this.heightMap.shouldUpdate({
          layers: terrainLayers,
          viewport
        });
        if (!shouldUpdate) {
          return;
        }
        this.terrainPass.renderHeightMap(this.heightMap, {
          ...opts,
          layers: terrainLayers,
          moduleParameters: {
            heightMapBounds: this.heightMap.bounds,
            dummyHeightMap: this.dummyHeightMap,
            devicePixelRatio: 1,
            drawToTerrainHeightMap: true
          }
        });
      }
      _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
        const layerNeedsRedraw = {};
        for (const layer of drapeLayers) {
          if (layer.state.terrainCoverNeedsRedraw) {
            layerNeedsRedraw[layer.id] = true;
            layer.state.terrainCoverNeedsRedraw = false;
          }
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({
            layerNeedsRedraw
          });
        }
        for (const layer of terrainLayers) {
          this._updateTerrainCover(layer, drapeLayers, viewport, opts);
        }
        if (!this.isPicking) {
          this._pruneTerrainCovers();
        }
      }
      _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
        const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
        let terrainCover = this.terrainCovers.get(terrainLayer.id);
        if (!terrainCover) {
          terrainCover = new TerrainCover(terrainLayer);
          this.terrainCovers.set(terrainLayer.id, terrainCover);
        }
        try {
          const isDirty = terrainCover.shouldUpdate({
            targetLayer: terrainLayer,
            viewport,
            layers: drapeLayers
          });
          if (this.isPicking || terrainCover.isDirty || isDirty) {
            renderPass.renderTerrainCover(terrainCover, {
              ...opts,
              layers: drapeLayers,
              moduleParameters: {
                dummyHeightMap: this.dummyHeightMap,
                terrainSkipRender: false,
                devicePixelRatio: 1
              }
            });
            terrainCover.isDirty = false;
          }
        } catch (err) {
          terrainLayer.raiseError(err, "Error rendering terrain cover ".concat(terrainCover.id));
        }
      }
      _pruneTerrainCovers() {
        const idsToRemove = [];
        for (const [id, terrainCover] of this.terrainCovers) {
          if (!terrainCover.isActive) {
            idsToRemove.push(id);
          }
        }
        for (const id of idsToRemove) {
          this.terrainCovers.delete(id);
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js
var defaultProps8, TerrainExtension;
var init_terrain_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js"() {
    init_defineProperty();
    init_esm4();
    init_terrain_effect();
    init_shader_module5();
    defaultProps8 = {
      terrainDrawMode: void 0
    };
    TerrainExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [terrainModule]
        };
      }
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new TerrainEffect());
      }
      updateState(params) {
        const {
          props,
          oldProps
        } = params;
        if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
          return;
        }
        let {
          terrainDrawMode
        } = props;
        if (!terrainDrawMode) {
          var _this$getAttributeMan;
          const is3d = this.props.extruded;
          const attributes = (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.attributes;
          const hasAnchor = attributes && "instancePositions" in attributes;
          terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
        }
        this.setState({
          terrainDrawMode
        });
      }
      onNeedsRedraw() {
        const state = this.state;
        if (state.terrainDrawMode === "drape") {
          state.terrainCoverNeedsRedraw = true;
        }
      }
    };
    _defineProperty(TerrainExtension, "defaultProps", defaultProps8);
    _defineProperty(TerrainExtension, "extensionName", "TerrainExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  BrushingExtension: () => BrushingExtension,
  ClipExtension: () => ClipExtension,
  CollisionFilterExtension: () => CollisionFilterExtension,
  DataFilterExtension: () => DataFilterExtension,
  FillStyleExtension: () => FillStyleExtension,
  Fp64Extension: () => Fp64Extension,
  MaskExtension: () => MaskExtension,
  PathStyleExtension: () => PathStyleExtension,
  _TerrainExtension: () => TerrainExtension,
  project64: () => project64_default
});
var init_esm5 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/index.js"() {
    init_brushing_extension();
    init_data_filter_extension();
    init_fp64_extension();
    init_path_style_extension();
    init_fill_style_extension();
    init_clip_extension();
    init_collision_filter_extension();
    init_mask_extension();
    init_terrain_extension();
    init_project64();
  }
});

export {
  BrushingExtension,
  DataFilterExtension,
  project64_default,
  Fp64Extension,
  PathStyleExtension,
  FillStyleExtension,
  ClipExtension,
  CollisionFilterExtension,
  MaskExtension,
  TerrainExtension,
  esm_exports,
  init_esm5 as init_esm
};
//# sourceMappingURL=chunk-3RPS2JYO.js.map
