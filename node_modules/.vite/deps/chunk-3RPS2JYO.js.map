{
  "version": 3,
  "sources": ["../../@deck.gl/extensions/src/brushing/shader-module.ts", "../../@deck.gl/extensions/src/brushing/brushing-extension.ts", "../../@deck.gl/extensions/src/data-filter/shader-module.ts", "../../@deck.gl/extensions/src/data-filter/aggregator.ts", "../../@deck.gl/extensions/src/data-filter/data-filter-extension.ts", "../../@deck.gl/extensions/src/fp64/project64.glsl.ts", "../../@deck.gl/extensions/src/fp64/project64.ts", "../../@deck.gl/extensions/src/fp64/fp64-extension.ts", "../../@deck.gl/extensions/src/path-style/shaders.glsl.ts", "../../@deck.gl/extensions/src/path-style/path-style-extension.ts", "../../@deck.gl/extensions/src/fill-style/shaders.glsl.ts", "../../@deck.gl/extensions/src/fill-style/fill-style-extension.ts", "../../@deck.gl/extensions/src/clip/clip-extension.ts", "../../@deck.gl/extensions/src/collision-filter/shader-module.ts", "../../@deck.gl/extensions/src/collision-filter/collision-filter-pass.ts", "../../@deck.gl/extensions/src/mask/mask-pass.ts", "../../@deck.gl/extensions/src/utils/projection-utils.ts", "../../@deck.gl/extensions/src/mask/mask-effect.ts", "../../@deck.gl/extensions/src/collision-filter/collision-filter-effect.ts", "../../@deck.gl/extensions/src/collision-filter/collision-filter-extension.ts", "../../@deck.gl/extensions/src/mask/shader-module.ts", "../../@deck.gl/extensions/src/mask/mask-extension.ts", "../../@deck.gl/extensions/src/terrain/shader-module.ts", "../../@deck.gl/extensions/src/terrain/utils.ts", "../../@deck.gl/extensions/src/terrain/terrain-cover.ts", "../../@deck.gl/extensions/src/terrain/terrain-pass.ts", "../../@deck.gl/extensions/src/terrain/terrain-picking-pass.ts", "../../@deck.gl/extensions/src/terrain/height-map-builder.ts", "../../@deck.gl/extensions/src/terrain/terrain-effect.ts", "../../@deck.gl/extensions/src/terrain/terrain-extension.ts", "../../@deck.gl/extensions/src/index.ts"],
  "sourcesContent": ["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable camelcase */\nimport {project} from '@deck.gl/core';\nimport type {Viewport, _ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {BrushingExtensionProps} from './brushing-extension';\n\ntype BrushingModuleSettings = {\n  // From layer context\n  viewport: Viewport;\n  mousePosition?: {x: number; y: number};\n} & BrushingExtensionProps;\n\nconst vs = `\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst fs = `\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: (opts?: BrushingModuleSettings | {}): Record<string, any> => {\n    if (!opts || !('viewport' in opts)) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      brushing_enabled: Boolean(\n        brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)\n      ),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition\n        ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])\n        : [0, 0]\n    };\n  }\n} as ShaderModule<BrushingModuleSettings>;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport shaderModule from './shader-module';\n\nimport type {Layer, LayerContext, Accessor} from '@deck.gl/core';\n\nconst defaultProps = {\n  getBrushingTarget: {type: 'accessor', value: [0, 0]},\n\n  brushingTarget: 'source',\n  brushingEnabled: true,\n  brushingRadius: 10000\n};\n\nexport type BrushingExtensionProps<DataT = any> = {\n  /**\n   * Called to retrieve an arbitrary position for each object that it will be filtered by.\n   * Only effective if `brushingTarget` is set to `custom`.\n   */\n  getBrushingTarget?: Accessor<DataT, [number, number]>;\n  /**\n   * Enable/disable brushing. If brushing is disabled, all objects are rendered.\n   * @default true\n   */\n  brushingEnabled?: boolean;\n  /**\n   * The position used to filter each object by.\n   */\n  brushingTarget?: 'source' | 'target' | 'source_target' | 'custom';\n  /** The brushing radius centered at the pointer, in meters. If a data object is within this circle, it is rendered; otherwise it is hidden.\n   * @default 10000\n   */\n  brushingRadius?: number;\n};\n\n/** Adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position. */\nexport default class BrushingExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'BrushingExtension';\n\n  getShaders(): any {\n    return {\n      modules: [shaderModule]\n    };\n  }\n\n  initializeState(this: Layer<BrushingExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        brushingTargets: {\n          size: 2,\n          accessor: 'getBrushingTarget',\n          shaderAttributes: {\n            brushingTargets: {\n              divisor: 0\n            },\n            instanceBrushingTargets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    // Trigger redraw when mouse moves\n    // TODO - expose this in a better way\n    this.state.onMouseMove = () => {\n      this.getCurrentLayer()?.setNeedsRedraw();\n    };\n    if (context.deck) {\n      // @ts-expect-error (2446) accessing protected property\n      context.deck.eventManager.on({\n        pointermove: this.state.onMouseMove,\n        pointerleave: this.state.onMouseMove\n      });\n    }\n  }\n\n  finalizeState(this: Layer<BrushingExtensionProps>, context: LayerContext, extension: this) {\n    // Remove event listeners\n    if (context.deck) {\n      // @ts-expect-error (2446) accessing protected property\n      context.deck.eventManager.off({\n        pointermove: this.state.onMouseMove,\n        pointerleave: this.state.onMouseMove\n      });\n    }\n  }\n}\n", "import {_ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {DataFilterExtensionProps} from './data-filter-extension';\n\n/*\n * data filter shader module\n */\nconst vs = `\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n`;\n\nconst fs = `\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n`;\n\ntype DataFilterModuleSettings = {\n  extensions: any[]; // used to detect if layer props are present\n} & DataFilterExtensionProps;\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts?: DataFilterModuleSettings | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n\n  return {\n    ...(Number.isFinite(filterRange[0])\n      ? {\n          filter_min: filterRange[0],\n          filter_softMin: filterSoftRange[0],\n          filter_softMax: filterSoftRange[1],\n          filter_max: filterRange[1]\n        }\n      : {\n          filter_min: filterRange.map(r => r[0]),\n          filter_softMin: filterSoftRange.map(r => r[0]),\n          filter_softMax: filterSoftRange.map(r => r[1]),\n          filter_max: filterRange.map(r => r[1])\n        }),\n    filter_enabled: filterEnabled,\n    filter_useSoftMargin: Boolean(opts.filterSoftRange),\n    filter_transformSize: filterEnabled && filterTransformSize,\n    filter_transformColor: filterEnabled && filterTransformColor\n  };\n}\n\nfunction getUniforms64(opts?: DataFilterModuleSettings | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.filter_min)) {\n    const min64High = Math.fround(uniforms.filter_min);\n    uniforms.filter_min -= min64High;\n    uniforms.filter_softMin -= min64High;\n    uniforms.filter_min64High = min64High;\n\n    const max64High = Math.fround(uniforms.filter_max);\n    uniforms.filter_max -= max64High;\n    uniforms.filter_softMax -= max64High;\n    uniforms.filter_max64High = max64High;\n  } else {\n    const min64High = uniforms.filter_min.map(Math.fround);\n    uniforms.filter_min = uniforms.filter_min.map((x, i) => x - min64High[i]);\n    uniforms.filter_softMin = uniforms.filter_softMin.map((x, i) => x - min64High[i]);\n    uniforms.filter_min64High = min64High;\n\n    const max64High = uniforms.filter_max.map(Math.fround);\n    uniforms.filter_max = uniforms.filter_max.map((x, i) => x - max64High[i]);\n    uniforms.filter_softMax = uniforms.filter_softMax.map((x, i) => x - max64High[i]);\n    uniforms.filter_max64High = max64High;\n  }\n  return uniforms;\n}\n\nconst inject = {\n  'vs:#main-start': `\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  `,\n\n  'vs:#main-end': `\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  `,\n\n  'vs:DECKGL_FILTER_SIZE': `\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\n\nexport const shaderModule: ShaderModule<DataFilterModuleSettings> = {\n  name: 'data-filter',\n  vs,\n  fs,\n  inject,\n  getUniforms\n};\n\nexport const shaderModule64: ShaderModule<DataFilterModuleSettings> = {\n  name: 'data-filter-fp64',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64\n};\n", "import {Model, Texture2D, Framebuffer, isWebGL2} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nconst AGGREGATE_VS = `\\\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n`;\n\nconst AGGREGATE_FS = `\\\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n`;\n\nexport function supportsFloatTarget(gl: WebGLRenderingContext): boolean {\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#Support_for_float_textures_doesnt_mean_you_can_render_into_them!\n  return Boolean(\n    gl.getExtension('EXT_float_blend') &&\n      // WebGL 2\n      (gl.getExtension('EXT_color_buffer_float') ||\n        // WebGL 1\n        gl.getExtension('WEBGL_color_buffer_float'))\n  );\n}\n\n// A 1x1 framebuffer object that encodes the total count of filtered items\nexport function getFramebuffer(gl: WebGLRenderingContext, useFloatTarget: boolean): Framebuffer {\n  if (useFloatTarget) {\n    return new Framebuffer(gl, {\n      width: 1,\n      height: 1,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n          format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n          type: GL.FLOAT,\n          mipmaps: false\n        })\n      }\n    });\n  }\n  return new Framebuffer(gl, {\n    width: 256,\n    height: 64,\n    depth: false\n  });\n}\n\n// Increments the counter based on dataFilter_value\nexport function getModel(\n  gl: WebGLRenderingContext,\n  shaderOptions: any,\n  useFloatTarget: boolean\n): Model {\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n  if (useFloatTarget) {\n    shaderOptions.defines.FLOAT_TARGET = 1;\n  }\n\n  return new Model(gl, {\n    id: 'data-filter-aggregation-model',\n    vertexCount: 1,\n    isInstanced: false,\n    drawMode: GL.POINTS,\n    vs: AGGREGATE_VS,\n    fs: AGGREGATE_FS,\n    ...shaderOptions\n  });\n}\n\nexport const parameters = {\n  blend: true,\n  blendFunc: [GL.ONE, GL.ONE, GL.ONE, GL.ONE],\n  blendEquation: [GL.FUNC_ADD, GL.FUNC_ADD],\n  depthTest: false\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport {shaderModule, shaderModule64} from './shader-module';\nimport * as aggregator from './aggregator';\nimport {readPixelsToArray, clear} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n  onFilteredItemsChange: {type: 'function', value: null, optional: true},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\nexport type DataFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor to retrieve the value for each object that it will be filtered by.\n   * Returns either a number (if `filterSize: 1`) or an array of numbers.\n   */\n  getFilterValue?: Accessor<DataT, number | number[]>;\n  /**\n   * Enable/disable the data filter. If the data filter is disabled, all objects are rendered.\n   * @default true\n   */\n  filterEnabled?: boolean;\n  /**\n   * The [min, max] bounds which defines whether an object should be rendered.\n   * If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden.\n   * @default [-1, 1]\n   */\n  filterRange?: [number, number] | [number, number][];\n  /**\n   * If specified, objects will be faded in/out instead of abruptly shown/hidden.\n   * When the filtered value is outside of the bounds defined by `filterSoftRange` but still within the bounds defined by `filterRange`, the object will be rendered as \"faded.\"\n   * @default null\n   */\n  filterSoftRange?: [number, number] | [number, number][] | null;\n  /**\n   * When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformSize?: boolean;\n  /**\n   * When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformColor?: boolean;\n  /**\n   * Only called if the `countItems` option is enabled.\n   */\n  onFilteredItemsChange?: (evt: {\n    /** The id of the source layer. */\n    id: string;\n    /** The number of data objects that pass the filter. */\n    count: number;\n  }) => void;\n};\n\ntype DataFilterExtensionOptions = {\n  /**\n   * The size of the filter (number of columns to filter by). The data filter can show/hide data based on 1-4 numeric properties of each object.\n   * @default 1\n   */\n  filterSize: number;\n  /**\n   * Use 64-bit precision instead of 32-bit.\n   * @default false\n   */\n  fp64: boolean;\n  /**\n   * If `true`, reports the number of filtered objects with the `onFilteredItemsChange` callback.\n   * @default `false`.\n   */\n  countItems: boolean;\n};\n\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nexport default class DataFilterExtension extends LayerExtension<DataFilterExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'DataFilterExtension';\n\n  constructor({\n    filterSize = 1,\n    fp64 = false,\n    countItems = false\n  }: Partial<DataFilterExtensionOptions> = {}) {\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    super({filterSize, fp64, countItems});\n  }\n\n  getShaders(this: Layer<DataFilterExtensionProps>, extension: this): any {\n    const {filterSize, fp64} = extension.opts;\n\n    return {\n      modules: [fp64 ? shaderModule64 : shaderModule],\n      defines: {\n        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n        DATAFILTER_DOUBLE: Boolean(fp64)\n      }\n    };\n  }\n\n  initializeState(this: Layer<DataFilterExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        filterValues: {\n          size: extension.opts.filterSize,\n          type: extension.opts.fp64 ? GL.DOUBLE : GL.FLOAT,\n          accessor: 'getFilterValue',\n          shaderAttributes: {\n            filterValues: {\n              divisor: 0\n            },\n            instanceFilterValues: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    const {gl} = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(gl);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: GL.UNSIGNED_BYTE,\n          normalized: true,\n          accessor: (object, {index}) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n\n      const filterFBO = aggregator.getFramebuffer(gl, useFloatTarget);\n      const filterModel = aggregator.getModel(\n        gl,\n        extension.getShaders.call(this, extension),\n        useFloatTarget\n      );\n      this.setState({filterFBO, filterModel});\n    }\n  }\n\n  updateState(\n    this: Layer<DataFilterExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<DataFilterExtensionProps>>\n  ) {\n    if (this.state.filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const filterNeedsUpdate =\n        // attributeManager must be defined for filterModel to be set\n        attributeManager!.attributes.filterValues.needsUpdate() ||\n        props.filterEnabled !== oldProps.filterEnabled ||\n        props.filterRange !== oldProps.filterRange ||\n        props.filterSoftRange !== oldProps.filterSoftRange;\n      if (filterNeedsUpdate) {\n        this.setState({filterNeedsUpdate});\n      }\n    }\n  }\n\n  draw(this: Layer<DataFilterExtensionProps>, params: any, extension: this) {\n    const {filterFBO, filterModel, filterNeedsUpdate} = this.state;\n    const {onFilteredItemsChange} = this.props;\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const {\n        attributes: {filterValues, filterIndices}\n      } = this.getAttributeManager()!;\n      filterModel.setVertexCount(this.getNumInstances());\n\n      const {gl} = this.context;\n      clear(gl, {framebuffer: filterFBO, color: [0, 0, 0, 0]});\n\n      filterModel\n        .updateModuleSettings(params.moduleParameters)\n        .setAttributes({\n          ...filterValues.getShaderAttributes(),\n          ...(filterIndices && filterIndices.getShaderAttributes())\n        })\n        .draw({\n          framebuffer: filterFBO,\n          parameters: {\n            ...aggregator.parameters,\n            viewport: [0, 0, filterFBO.width, filterFBO.height]\n          }\n        });\n      const color = readPixelsToArray(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({id: this.id, count});\n\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState(this: Layer<DataFilterExtensionProps>) {\n    const {filterFBO, filterModel} = this.state;\n    if (filterFBO) {\n      filterFBO.color.delete();\n      filterFBO.delete();\n      filterModel.delete();\n    }\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  // This is the local offset to the instance position\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n\n  // Apply web mercator projection (depends on coordinate system imn use)\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable camelcase */\nimport {fp64} from '@luma.gl/shadertools';\nconst {fp64ify, fp64ifyMatrix4} = fp64;\nimport {project, _memoize as memoize} from '@deck.gl/core';\n\nimport type {Viewport, _ShaderModule as ShaderModule} from '@deck.gl/core';\nimport project64Shader from './project64.glsl';\n\ntype Project64ModuleSettings = {\n  viewport: Viewport;\n};\n\nexport default {\n  name: 'project64',\n  dependencies: [project, fp64],\n  vs: project64Shader,\n  getUniforms\n} as ShaderModule<Project64ModuleSettings>;\n\n// TODO - this module should calculate the 64 bit uniforms\n// It is currently done by project to minimize duplicated work\n\nconst getMemoizedUniforms = memoize(calculateUniforms);\n\nfunction getUniforms(opts?: Project64ModuleSettings | {}): Record<string, any> {\n  if (opts && 'viewport' in opts) {\n    const {viewProjectionMatrix, scale} = opts.viewport;\n    // We only need to update fp64 uniforms if fp32 projection is being updated\n    return getMemoizedUniforms({viewProjectionMatrix, scale});\n  }\n  return {};\n}\n\nfunction calculateUniforms({\n  viewProjectionMatrix,\n  scale\n}: {\n  viewProjectionMatrix: number[];\n  scale: number;\n}) {\n  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);\n  const scaleFP64 = fp64ify(scale);\n\n  return {\n    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,\n    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,\n    project64_uScale: scaleFP64\n  };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport project64 from './project64';\n\nimport type {Layer} from '@deck.gl/core';\n\n/** @deprecated Adds the legacy 64-bit precision to geospatial layers. */\nexport default class Fp64Extension extends LayerExtension {\n  static extensionName = 'Fp64Extension';\n\n  getShaders(this: Layer): any {\n    const {coordinateSystem} = this.props;\n    if (\n      coordinateSystem !== COORDINATE_SYSTEM.LNGLAT &&\n      coordinateSystem !== COORDINATE_SYSTEM.DEFAULT\n    ) {\n      throw new Error('fp64: coordinateSystem must be LNGLAT');\n    }\n\n    return {\n      modules: [project64]\n    };\n  }\n}\n", "export const dashShaders = {\n  inject: {\n    'vs:#decl': `\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n`,\n\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n\n    'fs:#decl': `\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n`,\n\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        // caps are rounded, test the distance to solid ends\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n`\n  }\n};\n\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nattribute float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n`,\n    'vs:#main-end': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n`\n  }\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\nimport {dist} from 'gl-matrix/vec3';\n\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nexport type PathStyleExtensionProps<DataT = any> = {\n  /**\n   * Accessor for the dash array to draw each path with: `[dashSize, gapSize]` relative to the width of the path.\n   * Requires the `dash` option to be on.\n   */\n  getDashArray?: Accessor<DataT, [number, number]>;\n  /**\n   * Accessor for the offset to draw each path with, relative to the width of the path.\n   * Negative offset is to the left hand side, and positive offset is to the right hand side.\n   * @default 0\n   */\n  getOffset?: Accessor<DataT, number>;\n  /**\n   * If `true`, adjust gaps for the dashes to align at both ends.\n   * @default false\n   */\n  dashJustified?: boolean;\n  /**\n   * If `true`, gaps between solid strokes are pickable. If `false`, only the solid strokes are pickable.\n   * @default false\n   */\n  dashGapPickable?: boolean;\n};\n\ntype PathStyleExtensionOptions = {\n  /**\n   * Add capability to render dashed lines.\n   * @default false\n   */\n  dash: boolean;\n  /**\n   * Add capability to offset lines.\n   * @default false\n   */\n  offset: boolean;\n  /**\n   * Improve dash rendering quality in certain circumstances. Note that this option introduces additional performance overhead.\n   * @default false\n   */\n  highPrecisionDash: boolean;\n};\n\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nexport default class PathStyleExtension extends LayerExtension<PathStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'PathStyleExtension';\n\n  constructor({\n    dash = false,\n    offset = false,\n    highPrecisionDash = false\n  }: Partial<PathStyleExtensionOptions> = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer: Layer<PathStyleExtensionProps>): boolean {\n    return 'pathTesselator' in layer.state;\n  }\n\n  getShaders(this: Layer<PathStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(this: Layer<PathStyleExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(\n    this: Layer<PathStyleExtensionProps>,\n    params: UpdateParameters<Layer<PathStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms: any = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(this: Layer<PathStyleExtensionProps>, path: number[] | number[][]): number[] {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    return result;\n  }\n}\n", "import {project, fp64LowPart} from '@deck.gl/core';\nimport type {Viewport, _ShaderModule as ShaderModule, ProjectUniforms} from '@deck.gl/core';\n\nimport type {Texture2D} from '@luma.gl/webgl';\n\n/*\n * fill pattern shader module\n */\nconst patternVs = `\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\n`;\n\nconst patternFs = `\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\n\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n`;\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    fill_uv = geometry.position.xy;\n  `,\n\n  'vs:DECKGL_FILTER_COLOR': `\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (fill_patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  `\n};\n\ntype FillStyleModuleSettings =\n  | {\n      viewport: Viewport;\n      fillPatternEnabled?: boolean;\n      fillPatternMask?: boolean;\n    }\n  | {\n      fillPatternTexture: Texture2D;\n    };\n\n/* eslint-disable camelcase */\nfunction getPatternUniforms(\n  opts: FillStyleModuleSettings | {},\n  uniforms: Record<string, any>\n): Record<string, any> {\n  if (!opts) {\n    return {};\n  }\n  if ('fillPatternTexture' in opts) {\n    const {fillPatternTexture} = opts;\n    return {\n      fill_patternTexture: fillPatternTexture,\n      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]\n    };\n  }\n  if ('viewport' in opts) {\n    const {fillPatternMask = true, fillPatternEnabled = true} = opts;\n    const {project_uCommonOrigin: coordinateOriginCommon} = uniforms as ProjectUniforms;\n\n    const coordinateOriginCommon64Low = [\n      fp64LowPart(coordinateOriginCommon[0]),\n      fp64LowPart(coordinateOriginCommon[1])\n    ];\n\n    return {\n      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),\n      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,\n      fill_patternMask: fillPatternMask,\n      fill_patternEnabled: fillPatternEnabled\n    };\n  }\n  return {};\n}\n\nexport const patternShaders: ShaderModule<FillStyleModuleSettings> = {\n  name: 'fill-pattern',\n  vs: patternVs,\n  fs: patternFs,\n  inject,\n  dependencies: [project],\n  getUniforms: getPatternUniforms\n};\n", "import {LayerExtension} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {patternShaders} from './shaders.glsl';\n\nimport type {\n  Layer,\n  LayerContext,\n  Accessor,\n  AccessorFunction,\n  Texture,\n  UpdateParameters\n} from '@deck.gl/core';\n\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    }\n  },\n  fillPatternMapping: {type: 'object', value: {}, async: true},\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport type FillStyleExtensionProps<DataT = any> = {\n  /** Cheap toggle to enable/disable pattern fill. Requires the `pattern` option to be on.\n   * @default true\n   */\n  fillPatternEnabled?: boolean;\n  /** Sprite image url or texture that packs all your patterns into one layout. */\n  fillPatternAtlas?: string | Texture;\n  /** Pattern names mapped to pattern definitions, or a url that points to a JSON file. */\n  fillPatternMapping?:\n    | string\n    | Record<\n        string,\n        {\n          /** Left position of the pattern on the atlas */\n          x: number;\n          /** Top position of the pattern on the atlas */\n          y: number;\n          /** Width of the pattern */\n          width: number;\n          /** Height of the pattern */\n          height: number;\n        }\n      >;\n  /**\n   * Whether to treat the patterns as transparency masks.\n   * @default true\n   */\n  fillPatternMask?: boolean;\n  /** Accessor for the name of the pattern. */\n  getFillPattern?: AccessorFunction<DataT, string>;\n  /** Accessor for the scale of the pattern, relative to the original size. If the pattern is 24 x 24 pixels, scale `1` roughly yields 24 meters.\n   * @default 1\n   */\n  getFillPatternScale?: Accessor<DataT, number>;\n  /**\n   * Accessor for the offset of the pattern, relative to the original size. Offset `[0.5, 0.5]` shifts the pattern alignment by half.\n   * @default [0, 0]\n   */\n  getFillPatternOffset?: Accessor<DataT, [number, number]>;\n};\n\ntype FillStyleExtensionOptions = {\n  /** If `true`, adds the ability to tile the filled area with a pattern.\n   * @default false\n   */\n  pattern: boolean;\n};\n\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nexport default class FillStyleExtension extends LayerExtension<FillStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'FillStyleExtension';\n\n  constructor({pattern = false}: Partial<FillStyleExtensionOptions> = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer: Layer<FillStyleExtensionProps>): boolean {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n\n  getShaders(this: Layer<FillStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(this: Layer<FillStyleExtensionProps>, context: LayerContext, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager!.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(\n    this: Layer<FillStyleExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<FillStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager()!.invalidate('getFillPattern');\n    }\n  }\n\n  draw(this: Layer<FillStyleExtensionProps>, params: any, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {fillPatternAtlas} = this.props;\n    this.setModuleParameters({\n      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture\n    });\n  }\n\n  finalizeState(this: Layer<FillStyleExtensionProps>) {\n    const {emptyTexture} = this.state;\n    emptyTexture?.delete();\n  }\n\n  getPatternFrame(this: Layer<FillStyleExtensionProps>, name: string) {\n    const {fillPatternMapping} = this.getCurrentLayer()!.props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1],\n  clipByInstance: undefined\n};\n\nexport type ClipExtensionProps = {\n  /** Rectangular bounds to be used for clipping the rendered region, in `[left, bottom, right, top]`.\n   * @default [0, 0, 1, 1]\n   */\n  clipBounds?: [number, number, number, number];\n  /**\n   * Controls whether an object is clipped by its anchor (e.g. icon, point) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  clipByInstance?: boolean;\n};\n\nconst shaderFunction = `\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n`;\n\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs: ShaderModule = {\n  name: 'clip-vs',\n  vs: shaderFunction\n};\n\nconst injectionVs = {\n  'vs:#decl': `\nvarying float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': `\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n  'fs:#decl': `\nvarying float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': `\n  if (clip_isVisible < 0.5) discard;\n`\n};\n\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs: ShaderModule = {\n  name: 'clip-fs',\n  fs: shaderFunction\n};\n\nconst injectionFs = {\n  'vs:#decl': `\nvarying vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': `\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': `\nvarying vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': `\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n\n/** Adds support for clipping rendered layers by rectangular bounds. */\nexport default class ClipExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'ClipExtension';\n\n  getShaders(this: Layer<ClipExtensionProps>) {\n    // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n    // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n\n    // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n    // @ts-expect-error attributeManager is always defined for primitive layers\n    let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n    // Users can override by setting the `clipByInstance` prop\n    if (this.props.clipByInstance !== undefined) {\n      clipByInstance = Boolean(this.props.clipByInstance);\n    }\n    this.state.clipByInstance = clipByInstance;\n\n    return clipByInstance\n      ? {\n          modules: [shaderModuleVs],\n          inject: injectionVs\n        }\n      : {\n          modules: [shaderModuleFs],\n          inject: injectionFs\n        };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<ClipExtensionProps>>, {uniforms}: any): void {\n    const {clipBounds} = this.props;\n    if (this.state.clipByInstance) {\n      uniforms.clip_bounds = clipBounds;\n    } else {\n      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n\n      uniforms.clip_bounds = [\n        Math.min(corner0[0], corner1[0]),\n        Math.min(corner0[1], corner1[1]),\n        Math.max(corner0[0], corner1[0]),\n        Math.max(corner0[1], corner1[1])\n      ];\n    }\n  }\n}\n", "import {Framebuffer, Texture2D} from '@luma.gl/core';\nimport {project} from '@deck.gl/core';\nimport type {_ShaderModule as ShaderModule} from '@deck.gl/core';\n\nconst vs = `\n#ifdef NON_INSTANCED_MODEL\nattribute float collisionPriorities;\n#else\nattribute float instanceCollisionPriorities;\n#endif\n\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture2D(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision_enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project_uViewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n`;\n\nconst inject = {\n  'vs:#decl': `\n  float collision_fade = 1.0;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': `\n  if (collision_sort) {\n    #ifdef NON_INSTANCED_MODEL\n    float collisionPriority = collisionPriorities;\n    #else\n    float collisionPriority = instanceCollisionPriorities;\n    #endif\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision_enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  `,\n  'vs:DECKGL_FILTER_COLOR': `\n  color.a *= collision_fade;\n  `\n};\n\ntype CollisionModuleSettings = {\n  collisionFBO?: Framebuffer;\n  drawToCollisionMap?: boolean;\n  dummyCollisionMap?: Texture2D;\n};\n\n/* eslint-disable camelcase */\ntype CollisionUniforms = {collision_sort?: boolean; collision_texture?: Framebuffer | Texture2D};\n\nconst getCollisionUniforms = (\n  opts: CollisionModuleSettings | {},\n  uniforms: Record<string, any>\n): CollisionUniforms => {\n  if (!opts || !('dummyCollisionMap' in opts)) {\n    return {};\n  }\n  const {collisionFBO, drawToCollisionMap, dummyCollisionMap} = opts;\n  return {\n    collision_sort: Boolean(drawToCollisionMap),\n    collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap\n  };\n};\n\nexport default {\n  name: 'collision',\n  dependencies: [project],\n  vs,\n  inject,\n  getUniforms: getCollisionUniforms\n} as ShaderModule;\n", "import {Framebuffer, withParameters} from '@luma.gl/core';\nimport {_LayersPass as LayersPass, LayersPassRenderOptions} from '@deck.gl/core';\n\ntype CollisionFilterPassRenderOptions = LayersPassRenderOptions & {};\n\nexport default class CollisionFilterPass extends LayersPass {\n  renderCollisionMap(target: Framebuffer, options: CollisionFilterPassRenderOptions) {\n    const gl = this.gl;\n\n    const padding = 1;\n\n    return withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],\n        clearColor: [0, 0, 0, 0],\n        blend: false,\n        depthTest: true,\n        depthRange: [0, 1]\n      },\n      () => this.render({...options, target, pass: 'collision'})\n    );\n  }\n\n  getModuleParameters() {\n    // Draw picking colors into collision FBO\n    return {\n      drawToCollisionMap: true,\n      pickingActive: 1,\n      pickingAttribute: false,\n      lightSources: {}\n    };\n  }\n}\n", "import {Framebuffer, Texture2D, withParameters} from '@luma.gl/core';\nimport {_LayersPass as LayersPass, LayersPassRenderOptions} from '@deck.gl/core';\n\ntype MaskPassRenderOptions = LayersPassRenderOptions & {\n  /** The channel to render into, 0:red, 1:green, 2:blue, 3:alpha */\n  channel: number;\n};\n\nexport default class MaskPass extends LayersPass {\n  maskMap: Texture2D;\n  fbo: Framebuffer;\n\n  constructor(gl, props: {id: string; mapSize?: number}) {\n    super(gl, props);\n\n    const {mapSize = 2048} = props;\n\n    this.maskMap = new Texture2D(gl, {\n      width: mapSize,\n      height: mapSize,\n      parameters: {\n        [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n\n    this.fbo = new Framebuffer(gl, {\n      id: 'maskmap',\n      width: mapSize,\n      height: mapSize,\n      attachments: {\n        [gl.COLOR_ATTACHMENT0]: this.maskMap\n      }\n    });\n  }\n\n  render(options: MaskPassRenderOptions) {\n    const gl = this.gl;\n\n    const colorMask = [false, false, false, false];\n    colorMask[options.channel] = true;\n\n    return withParameters(\n      gl,\n      {\n        clearColor: [255, 255, 255, 255],\n        blend: true,\n        blendFunc: [gl.ZERO, gl.ONE],\n        blendEquation: gl.FUNC_SUBTRACT,\n        colorMask,\n        depthTest: false\n      },\n      () => super.render({...options, target: this.fbo, pass: 'mask'})\n    );\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.operation.includes('mask');\n  }\n\n  delete() {\n    this.fbo.delete();\n    this.maskMap.delete();\n  }\n}\n", "import {WebMercatorViewport, OrthographicViewport} from '@deck.gl/core';\nimport type {Layer, Viewport} from '@deck.gl/core';\n\n/** Bounds in CARTESIAN coordinates */\nexport type Bounds = [minX: number, minY: number, maxX: number, maxY: number];\n\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(\n  /** The layers to combine */\n  layers: Layer[],\n  /** A Viewport instance that is used to determine the type of the view */\n  viewport: Viewport\n): Bounds | null {\n  // Join the bounds of layer data\n  const bounds: Bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {viewport, autoOffset: false});\n      const topRightCommon = layer.projectPosition(layerBounds[1], {viewport, autoOffset: false});\n\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\n\nconst MAX_VIEWPORT_SIZE = 2048;\n\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts: {\n  /** The cartesian bounds of layers that will render into this texture */\n  bounds: Bounds;\n  /** Target width. If not specified, will be deduced from zoom */\n  width?: number;\n  /** Target height. If not specified, will be deduced from zoom */\n  height?: number;\n  /** Target zoom. If not specified, will be deduced from width and height */\n  zoom?: number;\n  /** Border around the viewport in pixels */\n  border?: number;\n  /** A viewport used to determine the output type */\n  viewport: Viewport;\n}): Viewport | null {\n  const {bounds, viewport, border = 0} = opts;\n  const {isGeospatial} = viewport;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const centerWorld = viewport.unprojectPosition([\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n    0\n  ]);\n\n  let {width, height, zoom} = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width! - border * 2;\n    height = height! - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial\n    ? new WebMercatorViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        longitude: centerWorld[0],\n        latitude: centerWorld[1],\n        zoom,\n        orthographic: true\n      })\n    : new OrthographicViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        target: centerWorld,\n        zoom,\n        flipY: false\n      });\n}\n\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport: Viewport, zRange?: [number, number]): Bounds {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld: Bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    viewportBoundsWorld = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [\n    viewportBottomLeftCommon[0],\n    viewportBottomLeftCommon[1],\n    viewportTopRightCommon[0],\n    viewportTopRightCommon[1]\n  ];\n}\n\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(\n  layerBounds: Bounds,\n  viewport: Viewport,\n  zRange?: [number, number]\n): Bounds {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (\n    layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] &&\n    layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]\n  ) {\n    return layerBounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [\n    Math.max(layerBounds[0], paddedBounds[0]),\n    Math.max(layerBounds[1], paddedBounds[1]),\n    Math.min(layerBounds[2], paddedBounds[2]),\n    Math.min(layerBounds[3], paddedBounds[3])\n  ];\n}\n\nfunction doubleBounds(bounds: Bounds): Bounds {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n", "import {Layer, Viewport, Effect, PreRenderOptions, CoordinateSystem, log} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views, isPicking}: PreRenderOptions\n  ): MaskPreRenderStats {\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap.width,\n            height: maskMap.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n", "import {Framebuffer, Renderbuffer, Texture2D, cssToDeviceRatio} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {Effect, Layer, PreRenderOptions, Viewport} from '@deck.gl/core';\nimport CollisionFilterPass from './collision-filter-pass';\nimport MaskEffect, {MaskPreRenderStats} from '../mask/mask-effect';\n// import {debugFBO} from '../utils/debug';\n\ntype CollisionFilterExtensionProps = {\n  collisionTestProps?: {};\n  collisionGroup: string;\n};\n\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\n\ntype RenderInfo = {\n  collisionGroup: string;\n  layers: Layer<CollisionFilterExtensionProps>[];\n  layerBounds: ([number[], number[]] | null)[];\n  allLayersLoaded: boolean;\n};\n\nexport default class CollisionFilterEffect implements Effect {\n  id = 'collision-filter-effect';\n  props = null;\n  useInPicking = true;\n  order = 1;\n\n  private channels: Record<string, RenderInfo> = {};\n  private collisionFilterPass?: CollisionFilterPass;\n  private collisionFBOs: Record<string, Framebuffer> = {};\n  private dummyCollisionMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {\n      effects: allEffects,\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views,\n      isPicking,\n      preRenderStats = {}\n    }: PreRenderOptions\n  ): void {\n    if (!this.dummyCollisionMap) {\n      this.dummyCollisionMap = new Texture2D(gl, {width: 1, height: 1});\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n\n    const collisionLayers = layers.filter(\n      // @ts-ignore\n      ({props: {visible, collisionEnabled}}) => visible && collisionEnabled\n    ) as Layer<CollisionFilterExtensionProps>[];\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n\n    if (!this.collisionFilterPass) {\n      this.collisionFilterPass = new CollisionFilterPass(gl, {id: 'default-collision-filter'});\n    }\n\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.constructor === MaskEffect);\n    const maskEffectRendered = (preRenderStats['mask-effect'] as MaskPreRenderStats)?.didRender;\n\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(gl, collisionLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged =\n      !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      collisionFBO.resize({\n        width: gl.canvas.width / DOWNSCALE,\n        height: gl.canvas.height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n\n  private _render(\n    renderInfo: RenderInfo,\n    {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      effects: PreRenderOptions['effects'];\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const {collisionGroup} = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n\n    const needsRender =\n      viewportChanged ||\n      // If render info is new\n      renderInfo === oldRenderInfo ||\n      // If sublayers have changed\n      !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n      // If a sublayer's bounds have been updated\n      renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n      // If a sublayer's isLoaded state has been updated\n      renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n      // Some prop is in transition\n      renderInfo.layers.some(layer => layer.props.transitions);\n\n    this.channels[collisionGroup] = renderInfo;\n\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n\n      // Rerender collision FBO\n      this.collisionFilterPass!.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        moduleParameters: {\n          // To avoid feedback loop forming between Framebuffer and active Texture.\n          dummyCollisionMap: this.dummyCollisionMap,\n          devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE\n        }\n      });\n    }\n  }\n\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  private _groupByCollisionGroup(\n    gl: WebGLRenderingContext,\n    collisionLayers: Layer<CollisionFilterExtensionProps>[]\n  ): Record<string, RenderInfo> {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const {collisionGroup} = layer.props;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true};\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(gl, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n\n    return channelMap;\n  }\n\n  getModuleParameters(layer: Layer): {\n    collisionFBO: Framebuffer;\n    dummyCollisionMap: Texture2D;\n  } {\n    const {collisionGroup} = (layer as Layer<CollisionFilterExtensionProps>).props;\n    const {collisionFBOs, dummyCollisionMap} = this;\n    return {collisionFBO: collisionFBOs[collisionGroup], dummyCollisionMap};\n  }\n\n  cleanup(): void {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n\n  createFBO(gl: WebGLRenderingContext, collisionGroup: string) {\n    const {width, height} = gl.canvas;\n    const collisionMap = new Texture2D(gl, {\n      width,\n      height,\n      parameters: {\n        [gl.TEXTURE_MIN_FILTER]: gl.NEAREST,\n        [gl.TEXTURE_MAG_FILTER]: gl.NEAREST,\n        [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n\n    const depthBuffer = new Renderbuffer(gl, {format: gl.DEPTH_COMPONENT16, width, height});\n    this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {\n      id: `Collision-${collisionGroup}`,\n      width,\n      height,\n      attachments: {\n        [gl.COLOR_ATTACHMENT0]: collisionMap,\n        [gl.DEPTH_ATTACHMENT]: depthBuffer\n      }\n    });\n  }\n\n  destroyFBO(collisionGroup: string) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    for (const attachment of Object.values(fbo.attachments as Texture2D[])) {\n      attachment.delete();\n    }\n    fbo.delete();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}\n", "import {Accessor, Layer, LayerContext, LayerExtension} from '@deck.gl/core';\nimport collision from './shader-module';\nimport CollisionFilterEffect from './collision-filter-effect';\n\nconst defaultProps = {\n  getCollisionPriority: {type: 'accessor', value: 0},\n  collisionEnabled: true,\n  collisionGroup: {type: 'string', value: 'default'},\n  collisionTestProps: {}\n};\n\nexport type CollisionFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor for collision priority. Must return a number in the range -1000 -> 1000. Features with higher values are shown preferentially.\n   */\n  getCollisionPriority?: Accessor<DataT, number>;\n\n  /**\n   * Enable/disable collisions. If collisions are disabled, all objects are rendered.\n   * @default true\n   */\n  collisionEnabled: boolean;\n\n  /**\n   * Collision group this layer belongs to. If it is not set, the 'default' collision group is used\n   */\n  collisionGroup?: string;\n\n  /**\n   * Props to override when rendering collision map\n   */\n  collisionTestProps?: {};\n};\n\n/** Allows layers to hide overlapping objects. */\nexport default class CollisionFilterExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'CollisionFilterExtension';\n\n  getShaders(this: Layer<CollisionFilterExtensionProps>): any {\n    return {modules: [collision]};\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<CollisionFilterExtensionProps>, {uniforms, context, moduleParameters}: any) {\n    const {collisionEnabled} = this.props;\n    const {collisionFBO, drawToCollisionMap} = moduleParameters;\n    const enabled = collisionEnabled && Boolean(collisionFBO);\n    uniforms.collision_enabled = enabled;\n\n    if (drawToCollisionMap) {\n      // Override any props with those defined in collisionTestProps\n      // @ts-ignore\n      this.props = this.clone(this.props.collisionTestProps).props;\n    }\n  }\n\n  initializeState(\n    this: Layer<CollisionFilterExtensionProps>,\n    context: LayerContext,\n    extension: this\n  ) {\n    if (this.getAttributeManager() === null) {\n      return;\n    }\n    this.context.deck?._addDefaultEffect(new CollisionFilterEffect());\n    const attributeManager = this.getAttributeManager();\n    attributeManager!.add({\n      collisionPriorities: {\n        size: 1,\n        accessor: 'getCollisionPriority',\n        shaderAttributes: {\n          collisionPriorities: {divisor: 0},\n          instanceCollisionPriorities: {divisor: 1}\n        }\n      }\n    });\n  }\n\n  getNeedsPickingBuffer(this: Layer<CollisionFilterExtensionProps>): boolean {\n    return this.props.collisionEnabled;\n  }\n}\n", "import {project} from '@deck.gl/core';\nimport type {_ShaderModule as ShaderModule} from '@deck.gl/core';\nimport type {Texture2D} from '@luma.gl/webgl';\n\nconst vs = `\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n`;\n\nconst fs = `\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask_enabled) {\n    return true;\n  }\n  vec4 maskColor = texture2D(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask_channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask_channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask_channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask_channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask_inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n`;\n\nconst inject = {\n  'vs:#decl': `\nvarying vec2 mask_texCoords;\n`,\n  'vs:#main-end': `\n   vec4 mask_common_position;\n   if (mask_maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n`,\n  'fs:#decl': `\nvarying vec2 mask_texCoords;\n`,\n  'fs:#main-start': `\n  if (mask_enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);\n    gl_FragColor = texture2D(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n`\n};\n\ntype MaskModuleSettings = {\n  maskMap?: Texture2D;\n};\n\n/* eslint-disable camelcase */\nconst getMaskUniforms = (opts?: MaskModuleSettings | {}): Record<string, any> => {\n  if (opts && 'maskMap' in opts) {\n    return {\n      mask_texture: opts.maskMap\n    };\n  }\n  return {};\n};\n\nexport default {\n  name: 'mask',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: getMaskUniforms\n} as ShaderModule<MaskModuleSettings>;\n", "import {COORDINATE_SYSTEM, Layer, LayerExtension, log} from '@deck.gl/core';\nimport mask from './shader-module';\nimport MaskEffect from './mask-effect';\n\nconst defaultProps = {\n  maskId: '',\n  maskByInstance: undefined,\n  maskInverted: false\n};\n\nexport type MaskExtensionProps = {\n  /**\n   * Id of the layer that defines the mask. The mask layer must use the prop `operation: 'mask'`.\n   * Masking is disabled if `maskId` is empty or no valid mask layer with the specified id is found.\n   */\n  maskId?: string;\n  /**\n   * controls whether an object is clipped by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  maskByInstance?: boolean;\n  /**\n   * Inverts the masking operation\n   */\n  maskInverted?: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class MaskExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'MaskExtension';\n\n  initializeState(this: Layer<MaskExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new MaskEffect());\n  }\n\n  getShaders(this: Layer<MaskExtensionProps>): any {\n    // Infer by geometry if 'maskByInstance' prop isn't explictly set\n    let maskByInstance = 'instancePositions' in this.getAttributeManager()!.attributes;\n    // Users can override by setting the `maskByInstance` prop\n    if (this.props.maskByInstance !== undefined) {\n      maskByInstance = Boolean(this.props.maskByInstance);\n    }\n    this.state.maskByInstance = maskByInstance;\n\n    return {\n      modules: [mask]\n    };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<MaskExtensionProps>>, {uniforms, context, moduleParameters}: any) {\n    uniforms.mask_maskByInstance = this.state.maskByInstance;\n    const {maskId, maskInverted} = this.props;\n    const {maskChannels} = moduleParameters;\n    const {viewport} = context;\n    if (maskChannels && maskChannels[maskId]) {\n      const {index, bounds, coordinateOrigin: fromCoordinateOrigin} = maskChannels[maskId];\n      let {coordinateSystem: fromCoordinateSystem} = maskChannels[maskId];\n      uniforms.mask_enabled = true;\n      uniforms.mask_channel = index;\n      uniforms.mask_inverted = maskInverted;\n\n      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        fromCoordinateSystem = viewport.isGeospatial\n          ? COORDINATE_SYSTEM.LNGLAT\n          : COORDINATE_SYSTEM.CARTESIAN;\n      }\n      const opts = {modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem};\n      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);\n      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);\n      uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];\n    } else {\n      if (maskId) {\n        log.warn(`Could not find a mask layer with id: ${maskId}`)();\n      }\n      uniforms.mask_enabled = false;\n    }\n  }\n}\n", "/* eslint-disable camelcase */\n\nimport {project} from '@deck.gl/core';\nimport type {_ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {Texture2D} from '@luma.gl/core';\nimport type {Bounds} from '../utils/projection-utils';\nimport type {TerrainCover} from './terrain-cover';\n\n/** Module parameters expected by the terrain shader module */\nexport type TerrainModuleSettings = {\n  pickingActive?: boolean;\n  heightMap: Texture2D | null;\n  heightMapBounds?: Bounds | null;\n  dummyHeightMap: Texture2D;\n  terrainCover?: TerrainCover | null;\n  drawToTerrainHeightMap?: boolean;\n  useTerrainHeightMap?: boolean;\n  terrainSkipRender?: boolean;\n};\n\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\n\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n  .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n  .join('\\n');\n\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  inject: {\n    'vs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'vs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'fs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts = {}, uniforms) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const {project_uCommonOrigin} = uniforms;\n\n      let mode: number = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler: Texture2D = dummyHeightMap;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds: number[] | null = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds!;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds!;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const isPicking = opts.pickingActive;\n        sampler = isPicking\n          ? terrainCover.getPickingFramebuffer()\n          : terrainCover.getRenderFramebuffer();\n        if (isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n\n      /* eslint-disable camelcase */\n      return {\n        terrain_mode: mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        terrain_bounds: bounds\n          ? [\n              bounds[0] - project_uCommonOrigin[0],\n              bounds[1] - project_uCommonOrigin[1],\n              bounds[2] - bounds[0],\n              bounds[3] - bounds[1]\n            ]\n          : [0, 0, 0, 0]\n      };\n    }\n    return null;\n  }\n} as ShaderModule<TerrainModuleSettings>;\n", "import {Framebuffer, Texture2D, isWebGL2} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nexport function createRenderTarget(\n  gl: WebGLRenderingContext,\n  opts: {\n    id: string;\n    float?: boolean;\n  }\n) {\n  return new Framebuffer(gl, {\n    id: opts.id,\n    attachments: {\n      [gl.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n        ...(opts.float && {\n          format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n          type: GL.FLOAT\n        }),\n        mipmaps: false,\n        parameters: {\n          [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,\n          [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n          [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n          [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n        }\n      })\n    }\n  });\n}\n", "import {Framebuffer} from '@luma.gl/core';\n\nimport type {Layer, Viewport} from '@deck.gl/core';\n\nimport {createRenderTarget} from './utils';\nimport {joinLayerBounds, makeViewport, getRenderBounds, Bounds} from '../utils/projection-utils';\n\ntype TileHeader = {\n  boundingBox: [min: number[], max: number[]];\n};\n\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  isDirty: boolean = true;\n  /** The terrain layer that this instance belongs to */\n  targetLayer: Layer;\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the terrain cover texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  private fbo?: Framebuffer;\n  private pickingFbo?: Framebuffer;\n  private layers: string[] = [];\n  private tile: TileHeader | null;\n  /** Cached version of targetLayer.getBounds() */\n  private targetBounds: [number[], number[]] | null = null;\n  /** targetBounds in cartesian space */\n  private targetBoundsCommon: Bounds | null = null;\n\n  constructor(targetLayer: Layer) {\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n\n  get id() {\n    return this.targetLayer.id;\n  }\n\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive(): boolean {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }: {\n    targetLayer?: Layer;\n    viewport?: Viewport;\n    layers?: Layer[];\n    layerNeedsRedraw?: Record<string, boolean>;\n  }): boolean {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n\n    return layersChanged || sizeChanged;\n  }\n\n  /** Compare layers with the last version. Only rerender if necessary. */\n  private _updateLayers(layers: Layer[]): boolean {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  private _updateViewport(viewport: Viewport): boolean {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [\n          bottomLeftCommon[0],\n          bottomLeftCommon[1],\n          topRightCommon[0],\n          topRightCommon[1]\n        ];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n\n    return shouldRedraw;\n  }\n\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.gl, {id: this.id});\n    }\n    return this.fbo;\n  }\n\n  getPickingFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {id: `${this.id}-picking`});\n    }\n    return this.pickingFbo;\n  }\n\n  filterLayers(layers: Layer[]) {\n    return layers.filter(({id}) => this.layers.includes(id));\n  }\n\n  delete() {\n    const {fbo, pickingFbo} = this;\n    if (fbo) {\n      fbo.texture.delete();\n      fbo.delete();\n    }\n    if (pickingFbo) {\n      pickingFbo.texture.delete();\n      pickingFbo.delete();\n    }\n  }\n}\n\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile: TileHeader, layers: Layer[]): Layer[] {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer: Layer): TileHeader | null {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {tile} = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent as Layer;\n  }\n  return null;\n}\n\nfunction intersect(b1?: [number[], number[]], b2?: [number[], number[]]): boolean {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}\n", "import {withParameters} from '@luma.gl/core';\nimport {Layer, Viewport, _LayersPass as LayersPass, LayersPassRenderOptions} from '@deck.gl/core';\nimport type {HeightMapBuilder} from './height-map-builder';\nimport type {TerrainCover} from './terrain-cover';\n\nimport GL from '@luma.gl/constants';\n\nexport type TerrainPassRenderOptions = LayersPassRenderOptions;\n\n/** Renders textures used by the TerrainEffect render pass */\nexport class TerrainPass extends LayersPass {\n  getRenderableLayers(viewport: Viewport, opts: TerrainPassRenderOptions): Layer[] {\n    const {layers} = opts;\n    const result: Layer[] = [];\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n      }\n    }\n\n    return result;\n  }\n\n  renderHeightMap(heightMap: HeightMapBuilder, opts: Partial<TerrainPassRenderOptions>) {\n    // console.log('Updating height map')\n    const target = heightMap.getRenderFramebuffer();\n    const viewport = heightMap.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    target.resize(viewport);\n\n    withParameters(\n      this.gl,\n      {\n        clearColor: [0, 0, 0, 0],\n        blend: true,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.MAX,\n        depthTest: false\n      },\n      () =>\n        this.render({\n          ...opts,\n          target,\n          pass: 'terrain-height-map',\n          layers: opts.layers!,\n          viewports: [viewport],\n          effects: []\n        })\n    );\n  }\n\n  renderTerrainCover(terrainCover: TerrainCover, opts: Partial<TerrainPassRenderOptions>) {\n    // console.log('Updating terrain cover ' + terrainCover.id)\n    const target = terrainCover.getRenderFramebuffer();\n    const viewport = terrainCover.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    const layers = terrainCover.filterLayers(opts.layers!);\n    target.resize(viewport);\n\n    withParameters(\n      this.gl,\n      {\n        clearColor: [0, 0, 0, 0],\n        depthTest: false\n      },\n      () =>\n        this.render({\n          ...opts,\n          target,\n          pass: `terrain-cover-${terrainCover.id}`,\n          layers,\n          effects: [],\n          viewports: [viewport]\n        })\n    );\n  }\n}\n", "import {\n  Layer,\n  Viewport,\n  LayersPassRenderOptions,\n  _PickLayersPass as PickLayersPass\n} from '@deck.gl/core';\nimport {withParameters} from '@luma.gl/core';\nimport type {TerrainCover} from './terrain-cover';\n\nexport type TerrainPickingPassRenderOptions = LayersPassRenderOptions & {\n  pickZ: boolean;\n};\n\n/** Renders textures used by the TerrainEffect picking pass */\nexport class TerrainPickingPass extends PickLayersPass {\n  /** Save layer index for use when drawing to terrain cover.\n   * When a terrain cover's picking buffer is rendered,\n   * we need to make sure each layer receives a consistent index (encoded in the alpha channel)\n   * so that a picked color can be decoded back to the correct layer.\n   * Updated in getRenderableLayers which is called in TerrainEffect.preRender\n   */\n  drawParameters: Record<string, any> = {};\n\n  getRenderableLayers(viewport: Viewport, opts: TerrainPickingPassRenderOptions): Layer[] {\n    const {layers} = opts;\n    const result: Layer[] = [];\n    this.drawParameters = {};\n    this._resetColorEncoder(opts.pickZ);\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;\n      }\n    }\n\n    return result;\n  }\n\n  renderTerrainCover(terrainCover: TerrainCover, opts: Partial<TerrainPickingPassRenderOptions>) {\n    // console.log('Updating terrain cover for picking ' + terrainCover.id)\n    const target = terrainCover.getPickingFramebuffer();\n    const viewport = terrainCover.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    const layers = terrainCover.filterLayers(opts.layers!);\n    const terrainLayer = terrainCover.targetLayer;\n    if (terrainLayer.props.pickable) {\n      layers.unshift(terrainLayer);\n    }\n    target.resize(viewport);\n\n    withParameters(\n      this.gl,\n      {\n        depthTest: false\n      },\n      () =>\n        this.render({\n          ...opts,\n          pickingFBO: target,\n          pass: `terrain-cover-picking-${terrainCover.id}`,\n          layers,\n          effects: [],\n          viewports: [viewport],\n          // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,\n          // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`\n          cullRect: undefined,\n          deviceRect: viewport,\n          pickZ: false\n        })\n    );\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): any {\n    if (this.drawParameters[layer.id]) {\n      return this.drawParameters[layer.id];\n    }\n    const parameters = super.getLayerParameters(layer, layerIndex, viewport);\n    parameters.blend = true;\n    return parameters;\n  }\n}\n", "import {Framebuffer} from '@luma.gl/core';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\nimport {createRenderTarget} from './utils';\n\nimport type {Viewport, Layer} from '@deck.gl/core';\n\nconst MAP_MAX_SIZE = 2048;\n\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the height map texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  protected fbo?: Framebuffer;\n  protected gl: WebGLRenderingContext;\n  /** Last rendered layers */\n  private layers: Layer[] = [];\n  /** Last layer.getBounds() */\n  private layersBounds: ([number[], number[]] | null)[] = [];\n  /** The union of layersBounds in cartesian space */\n  private layersBoundsCommon: Bounds | null = null;\n  private lastViewport: Viewport | null = null;\n\n  static isSupported(gl: WebGLRenderingContext): boolean {\n    return Framebuffer.isSupported(gl, {colorBufferFloat: true});\n  }\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n\n  /** Returns the height map framebuffer for read/write access.\n   * Returns null when the texture is invalid.\n   */\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.gl, {id: 'height-map', float: true});\n    }\n    return this.fbo;\n  }\n\n  /** Called every render cycle to check if the framebuffer needs update */\n  shouldUpdate({layers, viewport}: {layers: Layer[]; viewport: Viewport}): boolean {\n    const layersChanged =\n      layers.length !== this.layers.length ||\n      layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a terrain source,\n          // for example getElevation+updateTriggers, elevationScale, modelMatrix\n          layer !== this.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions ||\n          // Layer's geometry bounds have changed\n          layer.getBounds() !== this.layersBounds[i]\n      );\n\n    if (layersChanged) {\n      // Recalculate cached bounds\n      this.layers = layers;\n      this.layersBounds = layers.map(layer => layer.getBounds());\n      this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n    }\n\n    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n\n    if (!this.layersBoundsCommon) {\n      this.renderViewport = null;\n    } else if (layersChanged || viewportChanged) {\n      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        this.renderViewport = null;\n        return false;\n      }\n\n      this.bounds = bounds;\n      this.lastViewport = viewport;\n\n      const scale = viewport.scale;\n      const pixelWidth = (bounds[2] - bounds[0]) * scale;\n      const pixelHeight = (bounds[3] - bounds[1]) * scale;\n\n      this.renderViewport =\n        pixelWidth > 0 || pixelHeight > 0\n          ? makeViewport({\n              // It's not important whether the geometry is visible in this viewport, because\n              // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n              // However the viewport must have the same center and zoom as the screen viewport\n              // So that projection uniforms used for calculating z are the same\n              bounds: [\n                viewport.center[0] - 1,\n                viewport.center[1] - 1,\n                viewport.center[0] + 1,\n                viewport.center[1] + 1\n              ],\n              zoom: viewport.zoom,\n              width: Math.min(pixelWidth, MAP_MAX_SIZE),\n              height: Math.min(pixelHeight, MAP_MAX_SIZE),\n              viewport\n            })\n          : null;\n      return true;\n    }\n    return false;\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.color.delete();\n      this.fbo.delete();\n    }\n  }\n}\n", "import {Texture2D, ProgramManager} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\n\nimport {terrainModule, TerrainModuleSettings} from './shader-module';\nimport {TerrainCover} from './terrain-cover';\nimport {TerrainPass} from './terrain-pass';\nimport {TerrainPickingPass, TerrainPickingPassRenderOptions} from './terrain-picking-pass';\nimport {HeightMapBuilder} from './height-map-builder';\n\nimport type {Effect, PreRenderOptions, Layer, Viewport} from '@deck.gl/core';\n\n/** Class to manage terrain effect */\nexport class TerrainEffect implements Effect {\n  id = 'terrain-effect';\n  props = null;\n  useInPicking = true;\n\n  /** true if picking in the current pass */\n  private isPicking: boolean = false;\n  /** true if should use in the current pass */\n  private isDrapingEnabled: boolean = false;\n  /** An empty texture as placeholder */\n  private dummyHeightMap: Texture2D;\n  /** A texture encoding the ground elevation, updated once per redraw. Used by layers with offset mode */\n  private heightMap?: HeightMapBuilder;\n  private terrainPass!: TerrainPass;\n  private terrainPickingPass!: TerrainPickingPass;\n  /** One texture for each primitive terrain layer, into which the draped layers render */\n  private terrainCovers: Map<string, TerrainCover> = new Map();\n\n  initialize(gl: WebGLRenderingContext) {\n    this.dummyHeightMap = new Texture2D(gl, {\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(gl, {id: 'terrain'});\n    this.terrainPickingPass = new TerrainPickingPass(gl, {id: 'terrain-picking'});\n\n    if (HeightMapBuilder.isSupported(gl)) {\n      this.heightMap = new HeightMapBuilder(gl);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n\n    ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);\n  }\n\n  preRender(gl: WebGLRenderingContext, opts: PreRenderOptions): void {\n    if (!this.dummyHeightMap) {\n      // First time this effect is in use, initialize resources and register the shader module\n      this.initialize(gl);\n      for (const layer of opts.layers) {\n        // Force the terrain layer (and its descendents) to rebuild their models with the new shader\n        if (layer.props.operation.includes('terrain')) {\n          layer.setChangeFlags({extensionsChanged: true});\n        }\n      }\n    }\n\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n\n    const {viewports, isPicking = false} = opts;\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(\n      viewport,\n      opts as TerrainPickingPassRenderOptions\n    );\n\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n\n  getModuleParameters(layer: Layer): TerrainModuleSettings {\n    const {terrainDrawMode} = layer.state;\n\n    return {\n      heightMap: this.heightMap?.getRenderFramebuffer(),\n      heightMapBounds: this.heightMap?.bounds,\n      dummyHeightMap: this.dummyHeightMap,\n      terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n      useTerrainHeightMap: terrainDrawMode === 'offset',\n      terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n  }\n\n  private _updateHeightMap(terrainLayers: Layer[], viewport: Viewport, opts: PreRenderOptions) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n\n    const shouldUpdate = this.heightMap.shouldUpdate({layers: terrainLayers, viewport});\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      moduleParameters: {\n        heightMapBounds: this.heightMap.bounds,\n        dummyHeightMap: this.dummyHeightMap,\n        devicePixelRatio: 1,\n        drawToTerrainHeightMap: true\n      }\n    });\n  }\n\n  private _updateTerrainCovers(\n    terrainLayers: Layer[],\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw: Record<string, boolean> = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({layerNeedsRedraw});\n    }\n\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n\n  private _updateTerrainCover(\n    terrainLayer: Layer,\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          moduleParameters: {\n            dummyHeightMap: this.dummyHeightMap,\n            terrainSkipRender: false,\n            devicePixelRatio: 1\n          }\n        });\n        terrainCover.isDirty = false;\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err as Error, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n\n  private _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove: string[] = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}\n", "import {LayerExtension, UpdateParameters} from '@deck.gl/core';\nimport {TerrainEffect} from './terrain-effect';\nimport {terrainModule} from './shader-module';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\n\nexport type TerrainExtensionProps = {\n  /**\n   * controls whether an object is drawn over the terrain surface by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  terrainDrawMode?: 'offset' | 'drape';\n};\n\ntype TerrainExtensionState = {\n  /** Resolved fitting mode */\n  terrainDrawMode: 'offset' | 'drape';\n  /** Set when a layer is flagged as needs redraw */\n  terrainCoverNeedsRedraw: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class TerrainExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'TerrainExtension';\n\n  getShaders(this: Layer<TerrainExtensionProps>): any {\n    return {\n      modules: [terrainModule]\n    };\n  }\n\n  initializeState(this: Layer<TerrainExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new TerrainEffect());\n  }\n\n  updateState(\n    this: Layer<TerrainExtensionProps>,\n    params: UpdateParameters<Layer<TerrainExtensionProps>>\n  ) {\n    const {props, oldProps} = params;\n\n    if (\n      this.state.terrainDrawMode &&\n      props.terrainDrawMode === oldProps.terrainDrawMode &&\n      // @ts-ignore `extruded` may not exist in props\n      props.extruded === oldProps.extruded\n    ) {\n      return;\n    }\n\n    let {terrainDrawMode} = props;\n    if (!terrainDrawMode) {\n      // props.extruded is used as an indication that the layer is 2.5D\n      // @ts-ignore `extruded` may not exist in props\n      const is3d = this.props.extruded as boolean;\n      const attributes = this.getAttributeManager()?.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n    this.setState({terrainDrawMode});\n  }\n\n  onNeedsRedraw(this: Layer<{}>): void {\n    const state = this.state as TerrainExtensionState;\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  }\n}\n", "export {default as BrushingExtension} from './brushing/brushing-extension';\nexport {default as DataFilterExtension} from './data-filter/data-filter-extension';\nexport {default as Fp64Extension} from './fp64/fp64-extension';\nexport {default as PathStyleExtension} from './path-style/path-style-extension';\nexport {default as FillStyleExtension} from './fill-style/fill-style-extension';\nexport {default as ClipExtension} from './clip/clip-extension';\nexport {default as CollisionFilterExtension} from './collision-filter/collision-filter-extension';\nexport {default as MaskExtension} from './mask/mask-extension';\nexport {default as _TerrainExtension} from './terrain/terrain-extension';\n\n// Shader module\nexport {default as project64} from './fp64/project64';\n\n// Types\nexport type {BrushingExtensionProps} from './brushing/brushing-extension';\nexport type {DataFilterExtensionProps} from './data-filter/data-filter-extension';\nexport type {PathStyleExtensionProps} from './path-style/path-style-extension';\nexport type {FillStyleExtensionProps} from './fill-style/fill-style-extension';\nexport type {ClipExtensionProps} from './clip/clip-extension';\nexport type {CollisionFilterExtensionProps} from './collision-filter/collision-filter-extension';\nexport type {MaskExtensionProps} from './mask/mask-extension';\nexport type {TerrainExtensionProps} from './terrain/terrain-extension';\n"],
  "mappings": "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",
  "names": ["vs", "fs", "TARGET", "inject", "init_esm", "source", "target", "custom", "source_target", "name", "dependencies", "project", "getUniforms", "opts", "brushingEnabled", "brushingRadius", "brushingTarget", "mousePosition", "viewport", "brushing_enabled", "Boolean", "containsPixel", "brushing_radius", "brushing_target", "brushing_mousePos", "unproject", "x", "y", "defaultProps", "BrushingExtension", "init_esm", "getBrushingTarget", "type", "value", "brushingTarget", "brushingEnabled", "brushingRadius", "LayerExtension", "getShaders", "modules", "shaderModule", "initializeState", "context", "extension", "attributeManager", "getAttributeManager", "add", "brushingTargets", "size", "accessor", "shaderAttributes", "divisor", "instanceBrushingTargets", "state", "onMouseMove", "getCurrentLayer", "setNeedsRedraw", "deck", "eventManager", "on", "pointermove", "pointerleave", "finalizeState", "off", "getUniforms", "opts", "filterRange", "filterEnabled", "filterTransformSize", "filterTransformColor", "filterSoftRange", "Number", "isFinite", "filter_min", "filter_softMin", "filter_softMax", "filter_max", "map", "r", "filter_enabled", "filter_useSoftMargin", "Boolean", "filter_transformSize", "filter_transformColor", "getUniforms64", "uniforms", "min64High", "Math", "fround", "filter_min64High", "max64High", "filter_max64High", "x", "i", "vs", "fs", "inject", "shaderModule", "shaderModule64", "init_shader_module", "name", "supportsFloatTarget", "gl", "Boolean", "getExtension", "getFramebuffer", "useFloatTarget", "Framebuffer", "width", "height", "attachments", "Texture2D", "format", "isWebGL2", "type", "mipmaps", "depth", "getModel", "shaderOptions", "defines", "NON_INSTANCED_MODEL", "FLOAT_TARGET", "Model", "id", "vertexCount", "isInstanced", "drawMode", "vs", "AGGREGATE_VS", "fs", "AGGREGATE_FS", "parameters", "init_esm", "blend", "blendFunc", "blendEquation", "depthTest", "defaultProps", "DATA_TYPE_FROM_SIZE", "DataFilterExtension", "init_esm", "init_shader_module", "getFilterValue", "type", "value", "onFilteredItemsChange", "optional", "filterEnabled", "filterRange", "filterSoftRange", "filterTransformSize", "filterTransformColor", "LayerExtension", "constructor", "filterSize", "fp64", "countItems", "Error", "getShaders", "extension", "opts", "modules", "shaderModule64", "shaderModule", "defines", "DATAFILTER_TYPE", "DATAFILTER_DOUBLE", "Boolean", "initializeState", "context", "attributeManager", "getAttributeManager", "add", "filterValues", "size", "accessor", "shaderAttributes", "divisor", "instanceFilterValues", "gl", "useFloatTarget", "supportsFloatTarget", "filterIndices", "vertexOffset", "normalized", "object", "index", "i", "__source", "Math", "floor", "filterPrevIndices", "filterFBO", "getFramebuffer", "filterModel", "getModel", "call", "setState", "updateState", "props", "oldProps", "state", "filterNeedsUpdate", "attributes", "needsUpdate", "draw", "params", "setVertexCount", "getNumInstances", "clear", "framebuffer", "color", "updateModuleSettings", "moduleParameters", "setAttributes", "getShaderAttributes", "parameters", "viewport", "width", "height", "readPixelsToArray", "count", "length", "id", "finalizeState", "delete", "getUniforms", "opts", "viewProjectionMatrix", "scale", "viewport", "getMemoizedUniforms", "calculateUniforms", "glViewProjectionMatrixFP64", "fp64ifyMatrix4", "scaleFP64", "fp64ify", "project_uViewProjectionMatrixFP64", "project64_uViewProjectionMatrix", "project64_uScale", "init_esm", "fp64", "name", "dependencies", "project", "vs", "project64Shader", "memoize", "Fp64Extension", "init_esm", "LayerExtension", "getShaders", "coordinateSystem", "props", "COORDINATE_SYSTEM", "LNGLAT", "DEFAULT", "Error", "modules", "project64", "dashShaders", "offsetShaders", "inject", "defaultProps", "PathStyleExtension", "init_esm", "getDashArray", "type", "value", "getOffset", "dashJustified", "dashGapPickable", "LayerExtension", "constructor", "dash", "offset", "highPrecisionDash", "isEnabled", "layer", "state", "getShaders", "extension", "result", "opts", "mergeShaders", "dashShaders", "offsetShaders", "initializeState", "context", "attributeManager", "getAttributeManager", "addInstanced", "instanceDashArrays", "size", "accessor", "instanceDashOffsets", "transform", "getDashOffsets", "bind", "instanceOffsets", "updateState", "params", "uniforms", "dashAlignMode", "props", "Boolean", "model", "setUniforms", "path", "positionSize", "positionFormat", "isNested", "Array", "isArray", "geometrySize", "length", "p", "prevP", "i", "slice", "projectPosition", "dist", "getPatternUniforms", "opts", "uniforms", "fillPatternTexture", "fill_patternTexture", "fill_patternTextureSize", "width", "height", "fillPatternMask", "fillPatternEnabled", "project_uCommonOrigin", "coordinateOriginCommon", "coordinateOriginCommon64Low", "fp64LowPart", "fill_uvCoordinateOrigin", "slice", "fill_uvCoordinateOrigin64Low", "fill_patternMask", "fill_patternEnabled", "patternVs", "patternFs", "inject", "patternShaders", "init_shaders_glsl", "init_esm", "name", "vs", "fs", "dependencies", "project", "getUniforms", "defaultProps", "FillStyleExtension", "init_esm", "init_shaders_glsl", "fillPatternEnabled", "fillPatternAtlas", "type", "value", "async", "parameters", "fillPatternMapping", "fillPatternMask", "getFillPattern", "d", "pattern", "getFillPatternScale", "getFillPatternOffset", "LayerExtension", "constructor", "isEnabled", "layer", "getAttributeManager", "state", "getShaders", "extension", "modules", "opts", "patternShaders", "filter", "Boolean", "initializeState", "context", "attributeManager", "add", "fillPatternFrames", "size", "accessor", "transform", "getPatternFrame", "bind", "shaderAttributes", "divisor", "instanceFillPatternFrames", "fillPatternScales", "defaultValue", "instanceFillPatternScales", "fillPatternOffsets", "instanceFillPatternOffsets", "setState", "emptyTexture", "Texture2D", "gl", "data", "Uint8Array", "width", "height", "updateState", "props", "oldProps", "invalidate", "draw", "params", "setModuleParameters", "fillPatternTexture", "finalizeState", "delete", "name", "getCurrentLayer", "def", "x", "y", "defaultProps", "shaderFunction", "shaderModuleVs", "injectionVs", "shaderModuleFs", "injectionFs", "ClipExtension", "init_esm", "clipBounds", "clipByInstance", "undefined", "name", "vs", "fs", "LayerExtension", "getShaders", "getAttributeManager", "attributes", "props", "Boolean", "state", "modules", "inject", "draw", "uniforms", "clip_bounds", "corner0", "projectPosition", "corner1", "Math", "min", "max", "vs", "inject", "getCollisionUniforms", "shader_module_default", "init_shader_module", "init_esm", "opts", "uniforms", "collisionFBO", "drawToCollisionMap", "dummyCollisionMap", "collision_sort", "Boolean", "collision_texture", "name", "dependencies", "project", "getUniforms", "CollisionFilterPass", "init_esm", "LayersPass", "renderCollisionMap", "target", "options", "gl", "padding", "withParameters", "scissorTest", "scissor", "width", "height", "clearColor", "blend", "depthTest", "depthRange", "render", "pass", "getModuleParameters", "drawToCollisionMap", "pickingActive", "pickingAttribute", "lightSources", "MaskPass", "init_esm", "LayersPass", "constructor", "gl", "props", "mapSize", "maskMap", "Texture2D", "width", "height", "parameters", "fbo", "Framebuffer", "id", "attachments", "render", "options", "colorMask", "channel", "withParameters", "clearColor", "blend", "blendFunc", "blendEquation", "depthTest", "target", "pass", "shouldDrawLayer", "layer", "operation", "includes", "delete", "joinLayerBounds", "layers", "viewport", "bounds", "Infinity", "layer", "layerBounds", "getBounds", "bottomLeftCommon", "projectPosition", "autoOffset", "topRightCommon", "Math", "min", "max", "Number", "isFinite", "makeViewport", "opts", "border", "isGeospatial", "centerWorld", "unprojectPosition", "width", "height", "zoom", "undefined", "scale", "log2", "round", "abs", "maxSize", "MAX_VIEWPORT_SIZE", "r", "WebMercatorViewport", "id", "x", "y", "longitude", "latitude", "orthographic", "OrthographicViewport", "target", "flipY", "getViewportBounds", "zRange", "viewportBoundsWorld", "length", "minZ", "maxZ", "bounds0", "z", "bounds1", "viewportBottomLeftCommon", "slice", "viewportTopRightCommon", "getRenderBounds", "viewportBounds", "paddedBounds", "doubleBounds", "dx", "dy", "centerX", "centerY", "init_esm", "MaskEffect", "init_esm", "preRender", "gl", "layers", "layerFilter", "viewports", "onViewportActive", "views", "isPicking", "didRender", "dummyMaskMap", "Texture2D", "width", "height", "maskLayers", "filter", "l", "props", "visible", "operation", "includes", "length", "masks", "channels", "maskPass", "MaskPass", "id", "maskMap", "channelMap", "_sortMaskChannels", "viewport", "viewportChanged", "lastViewport", "equals", "resolution", "undefined", "log", "warn", "maskId", "result", "_renderChannel", "channelInfo", "oldChannelInfo", "index", "maskChanged", "some", "layer", "i", "transitions", "layerBounds", "b", "bounds", "maskBounds", "joinLayerBounds", "getRenderBounds", "maskViewport", "makeViewport", "border", "getBounds", "render", "pass", "channel", "moduleParameters", "devicePixelRatio", "coordinateOrigin", "coordinateSystem", "channelCount", "root", "findIndex", "c", "push", "getModuleParameters", "maskChannels", "cleanup", "delete", "DOWNSCALE", "CollisionFilterEffect", "init_esm", "preRender", "gl", "effects", "allEffects", "layers", "layerFilter", "viewports", "onViewportActive", "views", "isPicking", "preRenderStats", "dummyCollisionMap", "Texture2D", "width", "height", "collisionLayers", "filter", "props", "visible", "collisionEnabled", "length", "channels", "collisionFilterPass", "CollisionFilterPass", "id", "e", "constructor", "MaskEffect", "maskEffectRendered", "didRender", "_groupByCollisionGroup", "viewport", "viewportChanged", "lastViewport", "equals", "collisionGroup", "collisionFBO", "collisionFBOs", "renderInfo", "resize", "canvas", "_render", "oldRenderInfo", "needsRender", "deepEqual", "layerBounds", "some", "b", "i", "allLayersLoaded", "layer", "transitions", "renderCollisionMap", "pass", "moduleParameters", "devicePixelRatio", "cssToDeviceRatio", "channelMap", "channelInfo", "push", "getBounds", "isLoaded", "Object", "keys", "createFBO", "destroyFBO", "getModuleParameters", "cleanup", "delete", "undefined", "collisionMap", "parameters", "depthBuffer", "Renderbuffer", "format", "Framebuffer", "attachments", "fbo", "attachment", "values", "defaultProps", "CollisionFilterExtension", "init_esm", "init_shader_module", "getCollisionPriority", "type", "value", "collisionEnabled", "collisionGroup", "collisionTestProps", "LayerExtension", "getShaders", "modules", "collision", "draw", "uniforms", "context", "moduleParameters", "props", "collisionFBO", "drawToCollisionMap", "enabled", "Boolean", "collision_enabled", "clone", "initializeState", "extension", "getAttributeManager", "deck", "_addDefaultEffect", "CollisionFilterEffect", "attributeManager", "add", "collisionPriorities", "size", "accessor", "shaderAttributes", "divisor", "instanceCollisionPriorities", "getNeedsPickingBuffer", "vs", "fs", "inject", "getMaskUniforms", "shader_module_default", "init_shader_module", "init_esm", "opts", "mask_texture", "maskMap", "name", "dependencies", "project", "getUniforms", "defaultProps", "MaskExtension", "init_esm", "init_shader_module", "maskId", "maskByInstance", "undefined", "maskInverted", "LayerExtension", "initializeState", "context", "deck", "_addDefaultEffect", "MaskEffect", "getShaders", "getAttributeManager", "attributes", "props", "Boolean", "state", "modules", "mask", "draw", "uniforms", "moduleParameters", "mask_maskByInstance", "maskChannels", "viewport", "index", "bounds", "coordinateOrigin", "fromCoordinateOrigin", "coordinateSystem", "fromCoordinateSystem", "mask_enabled", "mask_channel", "mask_inverted", "COORDINATE_SYSTEM", "DEFAULT", "isGeospatial", "LNGLAT", "CARTESIAN", "opts", "modelMatrix", "bl", "projectPosition", "tr", "mask_bounds", "log", "warn", "TERRAIN_MODE", "TERRAIN_MODE_CONSTANTS", "terrainModule", "init_shader_module", "init_esm", "NONE", "WRITE_HEIGHT_MAP", "USE_HEIGHT_MAP", "USE_COVER", "USE_COVER_ONLY", "SKIP", "Object", "keys", "map", "key", "join", "name", "dependencies", "project", "inject", "getUniforms", "opts", "uniforms", "drawToTerrainHeightMap", "heightMap", "heightMapBounds", "dummyHeightMap", "terrainCover", "useTerrainHeightMap", "terrainSkipRender", "project_uCommonOrigin", "mode", "sampler", "bounds", "isPicking", "pickingActive", "getPickingFramebuffer", "getRenderFramebuffer", "terrain_mode", "terrain_map", "terrain_bounds", "createRenderTarget", "gl", "opts", "Framebuffer", "id", "attachments", "Texture2D", "float", "format", "isWebGL2", "type", "mipmaps", "parameters", "init_esm", "getIntersectingLayers", "sourceTile", "layers", "filter", "layer", "tile", "getTile", "intersect", "boundingBox", "props", "parent", "b1", "b2", "TerrainCover", "constructor", "targetLayer", "id", "isActive", "Boolean", "getCurrentLayer", "shouldUpdate", "viewport", "layerNeedsRedraw", "sizeChanged", "_updateViewport", "layersChanged", "_updateLayers", "needsRedraw", "length", "i", "map", "shouldRedraw", "targetBounds", "bottomLeftCommon", "projectPosition", "topRightCommon", "targetBoundsCommon", "getBounds", "joinLayerBounds", "newZoom", "Math", "ceil", "zoom", "bounds", "oldZoom", "renderViewport", "newBounds", "getRenderBounds", "oldBounds", "some", "x", "makeViewport", "getRenderFramebuffer", "fbo", "createRenderTarget", "context", "gl", "getPickingFramebuffer", "pickable", "pickingFbo", "filterLayers", "includes", "delete", "texture", "TerrainPass", "init_esm", "LayersPass", "getRenderableLayers", "viewport", "opts", "layers", "result", "drawParamsByIndex", "_getDrawLayerParams", "i", "length", "layer", "isComposite", "shouldDrawLayer", "push", "renderHeightMap", "heightMap", "target", "getRenderFramebuffer", "renderViewport", "resize", "withParameters", "gl", "clearColor", "blend", "blendFunc", "blendEquation", "depthTest", "render", "pass", "viewports", "effects", "renderTerrainCover", "terrainCover", "filterLayers", "id", "TerrainPickingPass", "init_esm", "PickLayersPass", "getRenderableLayers", "viewport", "opts", "layers", "result", "drawParameters", "_resetColorEncoder", "pickZ", "drawParamsByIndex", "_getDrawLayerParams", "i", "length", "layer", "isComposite", "shouldDrawLayer", "push", "id", "layerParameters", "renderTerrainCover", "terrainCover", "target", "getPickingFramebuffer", "renderViewport", "filterLayers", "terrainLayer", "targetLayer", "props", "pickable", "unshift", "resize", "withParameters", "gl", "depthTest", "render", "pickingFBO", "pass", "effects", "viewports", "cullRect", "undefined", "deviceRect", "getLayerParameters", "layerIndex", "parameters", "blend", "MAP_MAX_SIZE", "HeightMapBuilder", "init_esm", "isSupported", "gl", "Framebuffer", "colorBufferFloat", "constructor", "getRenderFramebuffer", "renderViewport", "fbo", "createRenderTarget", "id", "float", "shouldUpdate", "layers", "viewport", "layersChanged", "length", "some", "layer", "i", "props", "transitions", "getBounds", "layersBounds", "map", "layersBoundsCommon", "joinLayerBounds", "viewportChanged", "lastViewport", "equals", "bounds", "getRenderBounds", "scale", "pixelWidth", "pixelHeight", "makeViewport", "center", "zoom", "width", "Math", "min", "height", "delete", "color", "TerrainEffect", "init_esm", "init_shader_module", "Map", "initialize", "gl", "dummyHeightMap", "Texture2D", "width", "height", "data", "Uint8Array", "terrainPass", "TerrainPass", "id", "terrainPickingPass", "TerrainPickingPass", "HeightMapBuilder", "isSupported", "heightMap", "log", "warn", "ProgramManager", "getDefaultProgramManager", "addDefaultModule", "terrainModule", "preRender", "opts", "layer", "layers", "props", "operation", "includes", "setChangeFlags", "extensionsChanged", "pickZ", "isDrapingEnabled", "viewports", "isPicking", "viewport", "getRenderableLayers", "terrainLayers", "filter", "l", "length", "offsetLayers", "state", "terrainDrawMode", "_updateHeightMap", "drapeLayers", "_updateTerrainCovers", "getModuleParameters", "getRenderFramebuffer", "heightMapBounds", "bounds", "terrainCover", "terrainCovers", "get", "useTerrainHeightMap", "terrainSkipRender", "cleanup", "delete", "undefined", "values", "clear", "shouldUpdate", "renderHeightMap", "moduleParameters", "devicePixelRatio", "drawToTerrainHeightMap", "layerNeedsRedraw", "terrainCoverNeedsRedraw", "isDirty", "_updateTerrainCover", "_pruneTerrainCovers", "terrainLayer", "renderPass", "TerrainCover", "set", "targetLayer", "renderTerrainCover", "err", "raiseError", "idsToRemove", "isActive", "push", "defaultProps", "TerrainExtension", "init_esm", "init_shader_module", "terrainDrawMode", "undefined", "LayerExtension", "getShaders", "modules", "terrainModule", "initializeState", "context", "deck", "_addDefaultEffect", "TerrainEffect", "updateState", "params", "props", "oldProps", "state", "extruded", "is3d", "attributes", "getAttributeManager", "hasAnchor", "setState", "onNeedsRedraw", "terrainCoverNeedsRedraw", "init_esm"]
}
