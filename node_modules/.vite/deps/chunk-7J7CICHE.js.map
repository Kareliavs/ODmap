{
  "version": 3,
  "sources": ["../../d3-array/src/ascending.js", "../../d3-array/src/bisector.js", "../../d3-array/src/bisect.js", "../../d3-array/src/range.js", "../../d3-array/src/ticks.js", "../../d3-array/src/number.js", "../../d3-array/src/quantile.js", "../../d3-array/src/pairs.js", "../../d3-array/src/cross.js", "../../d3-array/src/descending.js", "../../d3-array/src/variance.js", "../../d3-array/src/deviation.js", "../../d3-array/src/extent.js", "../../d3-array/src/array.js", "../../d3-array/src/constant.js", "../../d3-array/src/identity.js", "../../d3-array/src/threshold/sturges.js", "../../d3-array/src/histogram.js", "../../d3-array/src/threshold/freedmanDiaconis.js", "../../d3-array/src/threshold/scott.js", "../../d3-array/src/max.js", "../../d3-array/src/mean.js", "../../d3-array/src/median.js", "../../d3-array/src/merge.js", "../../d3-array/src/min.js", "../../d3-array/src/permute.js", "../../d3-array/src/scan.js", "../../d3-array/src/shuffle.js", "../../d3-array/src/sum.js", "../../d3-array/src/transpose.js", "../../d3-array/src/zip.js", "../../d3-array/src/index.js"],
  "sourcesContent": ["export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n", "import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n", "import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n", "export default function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n", "var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n", "export default function(x) {\n  return x === null ? NaN : +x;\n}\n", "import number from \"./number\";\n\nexport default function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n", "export default function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n}\n\nexport function pair(a, b) {\n  return [a, b];\n}\n", "import {pair} from \"./pairs\";\n\nexport default function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n}\n", "export default function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n", "import number from \"./number\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n}\n", "import variance from \"./variance\";\n\nexport default function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n}\n", "export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n}\n", "var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n", "export default function(x) {\n  return function() {\n    return x;\n  };\n}\n", "export default function(x) {\n  return x;\n}\n", "export default function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n", "import {slice} from \"./array\";\nimport bisect from \"./bisect\";\nimport constant from \"./constant\";\nimport extent from \"./extent\";\nimport identity from \"./identity\";\nimport range from \"./range\";\nimport {tickStep} from \"./ticks\";\nimport sturges from \"./threshold/sturges\";\n\nexport default function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n", "import {map} from \"../array\";\nimport ascending from \"../ascending\";\nimport number from \"../number\";\nimport quantile from \"../quantile\";\n\nexport default function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n}\n", "import deviation from \"../deviation\";\n\nexport default function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n}\n", "export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n}\n", "import number from \"./number\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n}\n", "import ascending from \"./ascending\";\nimport number from \"./number\";\nimport quantile from \"./quantile\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return quantile(numbers.sort(ascending), 0.5);\n}\n", "export default function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n}\n", "export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n}\n", "export default function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n}\n", "import ascending from \"./ascending\";\n\nexport default function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n}\n", "export default function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n}\n", "export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n}\n", "import min from \"./min\";\n\nexport default function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n", "import transpose from \"./transpose\";\n\nexport default function() {\n  return transpose(arguments);\n}\n", "export {default as bisect, bisectRight, bisectLeft} from \"./bisect\";\nexport {default as ascending} from \"./ascending\";\nexport {default as bisector} from \"./bisector\";\nexport {default as cross} from \"./cross\";\nexport {default as descending} from \"./descending\";\nexport {default as deviation} from \"./deviation\";\nexport {default as extent} from \"./extent\";\nexport {default as histogram} from \"./histogram\";\nexport {default as thresholdFreedmanDiaconis} from \"./threshold/freedmanDiaconis\";\nexport {default as thresholdScott} from \"./threshold/scott\";\nexport {default as thresholdSturges} from \"./threshold/sturges\";\nexport {default as max} from \"./max\";\nexport {default as mean} from \"./mean\";\nexport {default as median} from \"./median\";\nexport {default as merge} from \"./merge\";\nexport {default as min} from \"./min\";\nexport {default as pairs} from \"./pairs\";\nexport {default as permute} from \"./permute\";\nexport {default as quantile} from \"./quantile\";\nexport {default as range} from \"./range\";\nexport {default as scan} from \"./scan\";\nexport {default as shuffle} from \"./shuffle\";\nexport {default as sum} from \"./sum\";\nexport {default as ticks, tickIncrement, tickStep} from \"./ticks\";\nexport {default as transpose} from \"./transpose\";\nexport {default as variance} from \"./variance\";\nexport {default as zip} from \"./zip\";\n"],
  "mappings": "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",
  "names": []
}
